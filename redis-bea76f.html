<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>redis详解&nbsp;|&nbsp;夕的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="redis详解">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">redis详解</h1>
    
  </header>
  <article id="https://www.notion.so/bea76ff86d4444e094ff7013003100bb" class="PageRoot"><h2 id="https://www.notion.so/2d0b48c027db45acba76f951f2aadb41" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2d0b48c027db45acba76f951f2aadb41"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">基本数据类型</span></span></h2><h3 id="https://www.notion.so/59124d4a3289495ba3855856c68c0ce5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/59124d4a3289495ba3855856c68c0ce5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">字符串</span></span></h3><div id="https://www.notion.so/061ff04992434831ba315fd1a92bea9b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis的字符串类型没有使用C语言的原生字符串类型，而是使用了一个自定义的结构体（SDS，Simple Dynamic String），他是一个带长度信息的字节数组。</span></span></p></div><pre id="https://www.notion.so/221dc20c17e24e80be125c02f7020b5e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>struct SDS&lt;T&gt;{
    T capitity;  //数组容量
    T len; //数组长度
    byte flags; //特殊标志位
    byte[] content; //数组内容
}
</span></span></span></code></pre><ol class="NumberedListWrapper"><li id="https://www.notion.so/def6c17e28404c10afc0d18c598c26c1" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">使用泛型T，可以在字符串比较短的时候len ,capitity 使用byte，short表示，节约内存。redis规定字符串长度不得超过512MB，创建字符串的时候len,capitity一样长，不同长度的字符串使用不同的结构体表示。</span></span></li><li id="https://www.notion.so/22ca1ce9637b4e9887171a55e5f79a39" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">字符串长度小于1MB时，扩容采用加倍策略，超过1MB时，每次扩容只会多分配1MB大小的空间</span></span></li></ol><h3 id="https://www.notion.so/9a340826e2794445af8275e18be4f2da" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9a340826e2794445af8275e18be4f2da"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">字典</span></span></h3><div id="https://www.notion.so/88e90c44e30c4cc3a01eb25df1a24ea3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了hash结构使用字典外，整个redis数据库的所有key,value也组成了一个全局字典，还有带过期时间的key集合也是一个字典，zset中存储的value和score值的映射关系也是通过字典结构实现的。</span></span></p></div><div id="https://www.notion.so/d49581ece0854d39a3044ea621bc8e32" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">字典结构内部包含两个hashtable,通常只有一个hashtable是有值的，在字典扩容时需要重新分配hashtable，然后进行渐进式搬移，知识后两个hashtable存储的分别是旧的hashtable和新的hashtable。搬移结束后，旧的hashtable被删除，新的hashtable取代。</span></span></p></div><div id="https://www.notion.so/11451f46650f4bf291f13d6c3755b642" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">hashtable的结构解决hash冲突采用的是拉链法（和java的hashMap相似）第一维是数组，第二维是链表，数组中存储第二维链表的第一个元素的指针。</span></span></p></div><div id="https://www.notion.so/7e12a34c8a8b4c429fc33b27c6f3bac2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于数据量比较大的字典扩容是比较耗时的，这是一个O(n)级别的操作，作为单线程的redis很难支持这样的耗时操作，所以redis使用渐进式hash小步迁移。（搬移操作在redis对字典的后续操作指令中（hset,hdel等），在客户端空闲时redis的定时任务会进行主动搬迁）。</span></span></p></div><div id="https://www.notion.so/26e1ad9efbef418691eb36f3f689fb51" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">正常情况下，当hash表中的元素个数等于第一维数组的长度，就会进行扩容，变为原数组的两倍。但是，如果Redis正在做bgsave，**为了减少内存也的过多分离（Copy On Write）**redis尽量不去扩容，但是当元素的个数已经达到第一维数组长度的5倍，会强制扩容。</span></span></p></div><blockquote id="https://www.notion.so/7c2212a1d9ef4864908fa174af2bdb61" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">写时复制技术</span></span><div id="https://www.notion.so/5760491f60c8415eb8cfa63337dcc837" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">写时复制技术最初产生于Unix系统，用于实现一种傻瓜式的进程创建：当发出fork( )系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为是非常耗时的，因为它需要：</span></span></p></div><div id="https://www.notion.so/dffd7fd853414e17a151661b81f25df7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">·   为子进程的页表分配页面</span></span></p></div><div id="https://www.notion.so/70a7feca0da14b10b1a12e7e1fa82b4e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">·   为子进程的页分配页面</span></span></p></div><div id="https://www.notion.so/1955f7c30f2f43a789d69607cfe0c6e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">·   初始化子进程的页表</span></span></p></div><div id="https://www.notion.so/54882d703a3d4d88bb832a8ba423d71b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">·   把父进程的页复制到子进程相应的页中</span></span></p></div><div id="https://www.notion.so/288cf9b6846b4057a849067ef8cdd640" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破坏了高速缓存中的内容。在大多数情况下，这样做常常是毫无意义的，因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。</span></span></p></div><div id="https://www.notion.so/9fde87f9c8c94b75ac8ac66af1644470" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">现在的Unix内核（包括Linux），采用一种更为有效的方法称之为写时复制（或COW）。这种思想相当简单：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</span></span></p></div></blockquote><div id="https://www.notion.so/2cbe0899ebe64dff8b6654ec783a3ba5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">缩容条件：元素个数小于数组长度的10%时，缩容不会考虑redis是否在bgsave。</span></span></p></div><h3 id="https://www.notion.so/fb32d0960da84010867e6c51144cdaf7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/fb32d0960da84010867e6c51144cdaf7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Set</span></span></h3><div id="https://www.notion.so/03310f2e6abd4d438c7ab3fa705b4195" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">set 结构底层也是字典，只不过所有的value都是null，其他和字典一样。</span></span></p></div><h3 id="https://www.notion.so/afec8bb703354e928bb5cdbc13cfc54c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/afec8bb703354e928bb5cdbc13cfc54c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">压缩列表（ziplist）</span></span></h3><div id="https://www.notion.so/49798ee1f3b942ff83e0a14cc1ee6320" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis为了节约内存空间，zset和hash容器对象在元素个数比较少的时候，采用压缩列表进行存储。</span></span></p></div><div id="https://www.notion.so/6d1d1f3c05464a7e96ccda418679b825" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">压缩列表是一块连续的内存空间，元素之间顺序存储，没有冗余空间。</span></span></p></div><pre id="https://www.notion.so/c76749e99a3540f3b4a602294a1b2b49" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>struct ziplist&lt;T&gt;{
    int32 zlbytes;  //整个压缩列表占用字节数
    int32 zltail_offset;  //最后一个元素距离压缩列表起始位置的偏移量，用于快速定位最后一个节点
    int16 zllength;   //元素个数
    T[] entries;    //元素内容列表，依次紧凑存储
    int8 zlend;     //标志压缩列表的结束，恒为 0xFF
}

struct entry{
    int&lt;var&gt; prevlen;   //前一个entry的字节长度
    int&lt;var&gt; encoding;  //元素类型编码
    optional byte[] content;  //元素内容
}
</span></span></span></code></pre><div id="https://www.notion.so/c2d6fb90770b4db4a1c1a8f72e3339c6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ziplist都是紧凑存储，没有冗余空间，意味着插入一个新的元素需要调用realloc拓展内存。如果ziplist占据内存过大，重新分配内存和拷贝内存就会有很大的消耗，所以ziplist不适合存储大型字符串，存储的元素也不宜过多。</span></span></p></div><div id="https://www.notion.so/2cdbfe964d1b492c8e549ee3d1243def" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">压缩列表使用 zltail_offset 字段快速定位到尾部，进而实现双向遍历。</span></span></p></div><h3 id="https://www.notion.so/83bc33b4758d40bb8476abc454aecc7c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/83bc33b4758d40bb8476abc454aecc7c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">快速列表</span></span></h3><div id="https://www.notion.so/017512af39664558b33925378e33ce3b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis早期版本存储列表数据结构使用的是压缩列表ziplist和普通的双向链表LinkedList，元素少时使用ziplist，多时使用LinkedList。</span></span></p></div><div id="https://www.notion.so/1da9b25087be41cd861568d81f85be32" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">考虑到链表附加空间（前后指针）相对太高，每个节点都需要单独分配，影响内存管理效率，后来使用quickList代替了ziplist和LinkedList。</span></span></p></div><div id="https://www.notion.so/0d3999f6155a47b9acb6414224455e49" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">quickList是ziplist和LinkedList的结合体，他将LinkedList按段切分，每一段使用ziplist紧凑存储，让多个ziplist之间使用双向指针串联起来。</span></span></p></div><div id="https://www.notion.so/9834596d3e3b4ed8bff690dea814d5ff" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">quickList默认每个ziplist的长度为8KB，超过这个大小，就会另起一个ziplist。ziplist长度可以由参数 list-max-ziplist-size 配置.</span></span></p></div><div id="https://www.notion.so/4491958e39e1477488c971f9e3c44687" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">压缩深度：quickList默认压缩深度为0，也就是不压缩。压缩深度由 list-compress-depth 决定。为了支持快速的push/pop操作，quickList首尾两个ziplist不压缩，此时压缩深度为1（几个元素不压缩）</span></span></p></div><h3 id="https://www.notion.so/a3e790795fb9407abc41a11f171542f7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a3e790795fb9407abc41a11f171542f7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">跳跃列表</span></span></h3><div id="https://www.notion.so/d0de6ad9c8ad4350b7e6aed7f016fefe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis的zset是一个复合结构，一方面他需要一个hash结构来存储value和score的值，另一方面需要提供按照score排序的功能，还需要能够指定score的范围来获取value列表的功能。</span></span></p></div><div id="https://www.notion.so/820ef5b3207c46abb91b79f546689bc1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">zset的内部实现是一个hash字典加一个跳跃链表（skiplist），简单来说，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">给链表加多级索引的结构，就是跳跃表</strong></span><span class="SemanticString">，</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.cnblogs.com/hunternet/p/11248192.html">https://www.cnblogs.com/hunternet/p/11248192.html</a></span></span></p></div><div id="https://www.notion.so/c46721b0745d45c9befce794648a9071" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于新插入的节点，都需要一个随机算法给它分配一个合理的层数，目前是这样的，level1 -&gt; 50%,level2-&gt;25%。。。每一层的晋升率是50%。最顶层是2的-63的概率。</span></span></p></div><div id="https://www.notion.so/6e765ac958df4002868c9bff73987e1f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果执行zadd时，value已经存在，但是score需要更新，并且更新后改变了排序位置，那么redis会直接删除这个节点然后在执行插入。排序时，如果score相同还需要比较value的值。</span></span></p></div><h2 id="https://www.notion.so/28c822e8fa094c6f98380e3a27e5a5fb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/28c822e8fa094c6f98380e3a27e5a5fb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">原理篇</span></span></h2><h3 id="https://www.notion.so/dbb001147a794663871a19cd66f007c3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/dbb001147a794663871a19cd66f007c3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程IO模型</span></span></h3><div id="https://www.notion.so/7627ad87795743bb9cf218eecff777ff" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis 是一个单线程程序，使用非阻塞IO处理并发客户端连接（多路复用，select系列事件轮询API）</span></span></p></div><div id="https://www.notion.so/c3bc77013700476682c627045d6bc06d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">非阻塞IO：当数据没有完全被内核准备好时，线程不阻塞而是直接返回，再次轮询请求是否准备好，当准备好时系统调用，将内核接收的数据拷贝到用户进程空间内。</span></span></p></div><div id="https://www.notion.so/c5d2269d6b1546d2987153b79d0fe58a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多路复用：使用一个线程监听连接，若连接就绪则开启一个线程进行处理。</span></span></p></div><h3 id="https://www.notion.so/ae99f8cca0174f32ace52f3893ffc905" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ae99f8cca0174f32ace52f3893ffc905"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">通信协议</span></span></h3><div id="https://www.notion.so/6b1a702f6de540d88bfdad9fec9a4105" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">RESP（redis serialization protocol）redis 序列化协议，一种直观的文本协议，优点在于实现过程简单，解析性能好。</span></span></p></div><h3 id="https://www.notion.so/9e0f8c5e21c742908484d4344abaec4c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9e0f8c5e21c742908484d4344abaec4c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">持久化</span></span></h3><div id="https://www.notion.so/ffc7a81cb1644bab8eba3038ff105b26" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis有两种持久化机制，第一种是快照，第二种是AOF日志。</span></span></p></div><div id="https://www.notion.so/0526c2732144456b8ac8becb8fb3c9fe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑。而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得无比庞大，数据库重启时需要加载AOF日志进行指令重放，这个时间会很长，所以需要定期对AOF进行重写，给AOF日志进行瘦身。</span></span></p></div><h3 id="https://www.notion.so/9c4c27985fe0439a93e7dbc79e032716" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9c4c27985fe0439a93e7dbc79e032716"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">快照原理</span></span></h3><div id="https://www.notion.so/e9d7633d5ccc4f049e19708d007080e3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis使用多进程COW（写时复制）机制进行快照持久化。</span></span></p></div><div id="https://www.notion.so/f7d2f97ac47b40e3a46c4ce041cdb62d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis在持久化时会调用glibc的函数fork()产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。</span></span></p></div><div id="https://www.notion.so/0c6d727381f347cdb5de3160f1839d91" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当父进程对其中一个内存页面的数据进行修改时，会将跟子进程共享的对应页面复制一份分离出来，然后对这个复制的页面进行修改，这时子进程相应的页面是没有变化的，还是进程产生那一瞬间产生的。子进程因为数据没有变化，它能看到的内存的数据是进程产生一瞬间的，所以叫做快照，接下来子进程就可以安心进行序列化写磁盘了。</span></span></p></div><h3 id="https://www.notion.so/c4dffc797ebc4e4dbd35abee29c9c702" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c4dffc797ebc4e4dbd35abee29c9c702"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">AOF日志原理</span></span></h3><div id="https://www.notion.so/086c7e2762d142c3930fe788cf9bb9aa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AOF日志存储的是redis服务器的顺序指令序列，AOF日志只记录对内存的修改指令记录。所以可以通过AOF日志进行重放，来恢复redis当前实例的内存数据状态。</span></span></p></div><div id="https://www.notion.so/1c2224f5cd9d4ec7837a992b2e069524" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis是先执行指令才将日志存盘，这点不同于hbase,levledb等，先存储日志在逻辑处理。</span></span></p></div><div id="https://www.notion.so/b34d1e28a6d748e48e2a22c7c4b6cf40" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AOF日志随时间会越来越长，重放AOF日志也会非常耗时，所以可以使用 bgrewriteaof指令进行AOF重写，原理是开辟一个子进程对内存进行遍历，转换成一系列的redis操作指令，序列化到一个新的AOF文件中，序列化完毕后再将操作期间增量AOF日志追加到新的AOF文件中，最后替换就的AOF文件。</span></span></p></div><div id="https://www.notion.so/f07f1b5a1143409da854912fc54eb94f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AOF日志是文件形式存在的，当程序对AOF日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存，然后内核异步将数据刷回磁盘。</span></span></p></div><div id="https://www.notion.so/8e04bbb0af66459eb96f86368f5e00d4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是如果机器突然宕机，AOF日志还未刷新，就会出现日志丢失。</span></span></p></div><div id="https://www.notion.so/dd1514a1dc1f4fa5be39bd28c65dc4ee" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Linux的glibc提供了fsync(int fd)函数可以将制定文件的内容强制刷新到磁盘。在实际中，redis通常每个1S执行一次此操作。此策略可以调整。</span></span></p></div><h3 id="https://www.notion.so/8fbbb4c780dd415797e49eac593ce0eb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8fbbb4c780dd415797e49eac593ce0eb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">混合持久化</span></span></h3><div id="https://www.notion.so/744fed39770c4671b929cbf0b9d2d5ba" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis4.0解决回复内存数据时间慢的问题，使用混合持久化。</span></span></p></div><div id="https://www.notion.so/88e7a166e4844665962ceafd4bf78e5c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将快照文件的内容和增量的AOF日志文件放到一起，这里的AOF不再是全量的日志，而是自持久化开始到结束的增量AOF，通常很少。</span></span></p></div><div id="https://www.notion.so/52481ef12db040f5822069471e2d479b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这样AOF重启可以先加载快照，在重放增量AOF日志，效率大幅提升。</span></span></p></div><h3 id="https://www.notion.so/84003f9a82224073a68d12210aab4780" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/84003f9a82224073a68d12210aab4780"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">事务</span></span></h3><div id="https://www.notion.so/e9c6d7feda9a4744b673ecb47a560834" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis 事务不具备原子性，而仅仅满足事务的隔离性中的串行化----当前事务有着不被其他事务打断的权利。</span></span></p></div><div id="https://www.notion.so/4eacab95635d4f6abebcb9e164332b1f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis提供了watch机制，它是一种乐观锁。watch会在事务开始之前盯住一个或多个关键变量，当事务执行时（exec），redis会检查关键变量在watch之后是否被修改了（包括当前事务所在的客户端）。如果被修改了就回返回null，执行失败，一般客户端会选择重试。</span></span></p></div><h2 id="https://www.notion.so/9cf770d7a1934e4dabcefc340eca68a1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9cf770d7a1934e4dabcefc340eca68a1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">集群</span></span></h2><h3 id="https://www.notion.so/37d96a7d7cd2402aaffb6c9268692a1a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/37d96a7d7cd2402aaffb6c9268692a1a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">sentinel（哨兵模式）</span></span></h3><div id="https://www.notion.so/e1f2d6b2750e46159c237291ae3db449" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis-sentinel集群可以看成是一个zookeeper集群，一般有3~5个节点组成，保证集群高可用。</span></span></p></div><div id="https://www.notion.so/c0de1b48a5fb4a4c90884c3beea7dd6a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">sentinel负责持续监控主从节点的健康，当主节点挂掉，自动选择一个最优的从节点切换称为主节点。客户端来连接集群时，会首先连接sentinel，通过sentinel来询问主节点的地址，然年在连接主节点进行数据交互；当主节点故障时，客户端会重新向sentinel要地址。</span></span></p></div><div id="https://www.notion.so/3ae6fe1a4f4f45ce91cc10fbd5cc0335" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redis主从采用异步复制，意味着当主节点挂掉时，从节点没有收到全部的同步信息；</span></span></p></div><div id="https://www.notion.so/dd92986ea3a74afa89137b0a05704523" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了尽量保证消息少丢失，sentinel使用两个选项限制主从延迟过大：</span></span></p></div><pre id="https://www.notion.so/81ec61c3a3d24551847dfcb894ca304a" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>min-slaves-to-write 1
min-slaves-max-lag 10
</span></span></span></code></pre><div id="https://www.notion.so/6bab41e4ddbd4472846618a608859afa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第一个参数表示主节点至少有一个从节点进行</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">正常复制</strong></span><span class="SemanticString">，否则就停止对外写服务，丧失可用性。</span></span></p></div><div id="https://www.notion.so/b0a73020c265416388d7a20ad3d50bac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第二个参数控制 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">正常复制</strong></span><span class="SemanticString">的条件，单位是秒，表示如果10秒内没有收到从节点的反馈，就代表从节点同步不正常。</span></span></p></div><h3 id="https://www.notion.so/8cd7fa09eea04a11b8690f55881ae557" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8cd7fa09eea04a11b8690f55881ae557"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Cluster</span></span></h3><h2 id="https://www.notion.so/e9ce9f1ce4aa4deaa91d6ebab8ed9a4c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e9ce9f1ce4aa4deaa91d6ebab8ed9a4c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">应用</span></span></h2><div id="https://www.notion.so/442dee891cd44f3bb4f4e10932cdeedd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">分布式锁  使用  set  变量 ex 过期时间  组成原子指令，这就是分布式锁</span></span></p></div><div id="https://www.notion.so/7cd41000e224448584b258178a202130" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">位图 bitmap  本质是字符串（byte数组）</span></span></p></div><div id="https://www.notion.so/efc409b6284d4cb582e83e2ce5655c50" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HyperLogLog  （去重）统计网页的UV（用户访问量） 标准误差0.81%</span></span></p></div><div id="https://www.notion.so/9354e3c01789406192955f8b0eb2a3cc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">布隆过滤器</span></span></p></div></article>
  <footer class="Footer">
  <div>&copy; 夕的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>