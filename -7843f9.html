<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>网络协议&nbsp;|&nbsp;夕的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="网络协议">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">网络协议</h1>
    
  </header>
  <article id="https://www.notion.so/7843f93b5abf46bb9abdb24e582fb9b3" class="PageRoot"><h2 id="https://www.notion.so/f51922a9a4dd4abcb974f62fe25b2eeb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f51922a9a4dd4abcb974f62fe25b2eeb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">TCP</span></span></h2><h3 id="https://www.notion.so/c1c5e87646984aa2a4ca2eb203bc1612" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c1c5e87646984aa2a4ca2eb203bc1612"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">三次握手</span></span></h3><div id="https://www.notion.so/ed714a4272b8497d85b15dc3758fc96b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</span></span></p></div><div id="https://www.notion.so/01980efcd83a4bd2abb5e93e0fab27d0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</span></span></p></div><div id="https://www.notion.so/8860465e7ccf4e55ac5582721b9b225e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</span></span></p></div><div id="https://www.notion.so/19ec64a753c741e6bf7b9276765357d3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么要三次握手？</strong></span></span></p></div><div id="https://www.notion.so/467d33c146df42df8516ea41cf6a382e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</span></span></p></div><div id="https://www.notion.so/ca780fd80dbc4734bd112446268aa16c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</span></span></p></div><h3 id="https://www.notion.so/0a682b2b78fb4d89ac19fdba8e7a00f2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/0a682b2b78fb4d89ac19fdba8e7a00f2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">四次挥手</span></span></h3><div id="https://www.notion.so/38d00aa5425642e1a39f1b26f94769bc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一次挥手：</strong></span><span class="SemanticString"> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</span></span></p></div><div id="https://www.notion.so/cb197a20f3704d7eb25ec430b5457f73" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第二次挥手：</strong></span><span class="SemanticString"> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</span></span></p></div><div id="https://www.notion.so/8c8952f1e0d74d5aa4c54c2c39a60d89" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第三次挥手：</strong></span><span class="SemanticString"> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</span></span></p></div><div id="https://www.notion.so/33f160d6f5c24e1190b6a7e39086ef71" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第四次挥手：</strong></span><span class="SemanticString"> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</span></span></p></div><div id="https://www.notion.so/4877e412d98a44a880610ef22293aef0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></span></span></p></div><div id="https://www.notion.so/32f48c5ecea34275a99fefb69bd5b4c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</span></span></p></div><div id="https://www.notion.so/a10f8154a7ee40be9f3ca7c9a523ea32" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么客户端最后还要等待2MSL？</strong></span></span></p></div><div id="https://www.notion.so/37a5dc636e5841c88ac45bccd4730bf0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</span></span></p></div><div id="https://www.notion.so/77f44261ffcf448a9e3d506514adb140" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</span></span></p></div><div id="https://www.notion.so/a72c360eac0843c98f1eb27b43d469c3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</span></span></p></div><div id="https://www.notion.so/ad348caf999c472bb8541b2b3e4613f9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></span></span></p></div><div id="https://www.notion.so/dac23e98fce94afd9e209b89adae52ae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</span></span></p></div><h3 id="https://www.notion.so/78a22153f5654047a4968fdb4c72c8c0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/78a22153f5654047a4968fdb4c72c8c0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">滑动窗口</span></span></h3><div id="https://www.notion.so/d02078fae6054149aae38fdbbc47de76" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">滑动窗口通俗来讲就是一种流量控制技术。（TCP首部中有16位窗口大小的字段）</span></span></p></div><div id="https://www.notion.so/394d72d42cf94aeeb6b4068e7e06553e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">	它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来。</span></span></p></div><div id="https://www.notion.so/e72f3b0bf8264e58b40c7a3a10e0df72" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"></span></span></p></div><h3 id="https://www.notion.so/ad24413cd7734bb78a9571c8e02e2c80" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ad24413cd7734bb78a9571c8e02e2c80"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">拥塞控制</span></span></h3><div id="https://www.notion.so/3809fe682e0a40f49945f6b017162bbe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一：滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的，对应==&gt;rwnd:接收端窗口（receiver window）</span></span></p></div><div id="https://www.notion.so/e73b34358f964413bc8aade1fd37b567" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于流量控制，是一个端对端的概念。由接收端返回的rwnd控制。</span></span></p></div><div id="https://www.notion.so/eb89e682de8b4af3a9d2daa3cafcd173" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">二：那么对于数据的发送端就是拥塞窗口了，拥塞窗口不代表缓存，拥塞窗口指某一源端数据流在一个RTT内可以最多发送的数据包数,cwnd:发送端窗口( congestion window )。</span></span></p></div><div id="https://www.notion.so/ac97cd25e67449ed90c0a8a62cdf9ebe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">拥塞控制： 发送端主动控制控制cwnd，有慢启动（从cwnd初始为1开始启动，指数启动），拥塞避免（到达ssthresh（慢启动阈值）后，为了避免拥塞开始尝试线性增长），快重传（接收方每收到一个报文段都要回复一个当前最大连续位置的确认，</span></span></p></div><div id="https://www.notion.so/791d4186d4434f9599683bcad00cdb16" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">发送方只要一连收到三个重复确认就知道接收方丢包了，快速重传丢包的报文，并TCP马上把拥塞窗口 cwnd 减小到1），快恢复（直接从ssthresh线性增长）。</span></span></p></div><div id="https://www.notion.so/37bdfef8d61441309a4005b0ac9e34c2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">三：发送方窗口是相互影响的，具体如下：</span></span></p></div><div id="https://www.notion.so/417d910543ed4c5bb4ad3f26a79f8a5f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">发送方窗口的上限值 = Min [ rwnd, cwnd ]</span></span></p></div><div id="https://www.notion.so/2a247aabf3574a228dc3efb60340ba4c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</span></span></p></div><div id="https://www.notion.so/76282f61e35e4a759c97a7f6bb83e054" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</span></span></p></div><div id="https://www.notion.so/b75698a7306346a98678f61a9e021205" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">四、TCP的滑动窗口大小实际上就是socket的接收缓冲区大小的字节数，可以用上层setopt来设置。</span></span></p></div><div id="https://www.notion.so/ab594b1be39b4a1eb57b9134fbe45acb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">五、对于server端的socket一定要在listen之间设置缓冲区大小，因为，accept时新产生的socket会继承监听socket</span></span></p></div><div id="https://www.notion.so/f1fcf02762e647c5829532baeca2e1d3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">的缓冲区大小。对于client端的socket一定要在connet之前设置缓冲区大小，因为connet时需要进行三次握手过程，</span></span></p></div><div id="https://www.notion.so/bd04f765b92346e2944ba051888f6cb8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">会通知对方自己的窗口大小。在connet之后再设置缓冲区，已经没有什么意义。</span></span></p></div><div id="https://www.notion.so/97d95588b880404da008427ac56f8409" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">流量控制和拥塞控制的区别</strong></span><span class="SemanticString">
1.相同点</span></span></p></div><div id="https://www.notion.so/f8edd284c3e5477eb32e4ea410c35da4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（1）现象都是丢包；
（2）实现机制都是让发送方发的慢一点，发的少一点</span></span></p></div><div id="https://www.notion.so/aeac9ecfc36b4d77b37e4be26919801a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2.不同点</span></span></p></div><div id="https://www.notion.so/88fa6b63a6694b41ba5b69dd77e96332" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（1）丢包位置不同
流量控制丢包位置是在接收端上
拥塞控制丢包位置是在路由器上
（2）作用的对象不同
流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理
拥塞控制的对象是网络，怕发送发发的太快，造成网络拥塞，使得网络来不及处理</span></span></p></div><h2 id="https://www.notion.so/9270b7fb82904d5299f9d4b0ad485430" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9270b7fb82904d5299f9d4b0ad485430"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">http/https</span></span></h2><h3 id="https://www.notion.so/99ce422d1e1e4ef8a3fc0c05e0dcab15" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/99ce422d1e1e4ef8a3fc0c05e0dcab15"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">http</span></span></h3><div id="https://www.notion.so/be3697aa26f74ded88afa765326be42b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">状态码</strong></span></span></p></div><div id="https://www.notion.so/cf7b010a66a84082b7bf4e0768d6ff2c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">1xx类属于提示信息，是协议处理的中间状态，实际不常用</span></span></p></div><div id="https://www.notion.so/f1fb993273134888b3670ef8bab71560" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2xx类表示服务端收到并成功处理客户端的请求，这也是客户端最愿意看到的状态码</span></span></p></div><div id="https://www.notion.so/713f2b526ad541b18cc408e6ed48f1b7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		200 OK 成功状态码，一切正常</span></span></p></div><div id="https://www.notion.so/3cf4490824b54b9ebdea2f999c43200b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		204 NO Content 常见的成功状态码，他的含义与200 OK基本相同，但是响应头后没有body数据</span></span></p></div><div id="https://www.notion.so/32eb8b02c0fe436db4aa2f75f35b0eb7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		206 Partial Content 是http分块下载或断点续传的基础，在客户端发送范围请求时出现。状态码 206 通常还会伴随着头字段“Content-Range”， 表示响应报文里 body 数据的具体范围，供客户端确认</span></span></p></div><div id="https://www.notion.so/c7bc85d361804d27b1d1b0a4bc582317" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">3xx类表示客户端请求的资源发生变动，客户端必须用新的URI重新发送请求获取资源，也就是重定向。</span></span></p></div><div id="https://www.notion.so/59159017bee749c4b28db14c0e562104" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		301 Moved Permanently 永久重定向</span></span></p></div><div id="https://www.notion.so/e20e1ff795dc49a7af390583421d8c52" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		302 Found 临时重定向</span></span></p></div><div id="https://www.notion.so/52b5fdee4c0545d18d1231f59b403449" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		304 Not Modified 它用 于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定 向已到缓存的文件”（即“缓存重定向”）。</span></span></p></div><div id="https://www.notion.so/ecbdad10fc5a445baa5661fb57e6fca5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">4xx类表示客户端发送的请求报文有误，服务器无法处理。</span></span></p></div><div id="https://www.notion.so/32919a6efa7f4affb21564325ef59f2a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		400 Bad Request 是一个通用的错误码，表示请求报 文有错误，但具体是数据格式错误、缺少请求头还是 URI 超 长它没有明确说，只是一个笼统的错误</span></span></p></div><div id="https://www.notion.so/427c2ffc2d21400f82f297299b8392dd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		403 Forbidden实际上不是客户端的请求出错，而是 表示服务器禁止访问资源。</span></span></p></div><div id="https://www.notion.so/d3e8bab7365945a98ee385c075325bea" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		404 Not Found可能是我们最常看见也是最不愿意看 到的一个状态码，它的原意是资源在本服务器上未找到，所 以无法提供给客户端。</span></span></p></div><div id="https://www.notion.so/f55be65026d34b239753a1977e54cdb5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">5xx类表示客户端请求报文正确，但服务器处理时内部发生了错误，无法返回应有的响应数据，是服务端的错误码</span></span></p></div><div id="https://www.notion.so/e8d906b8bf924b94ac5c4c74d14e7896" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		500 Internal Server Error与 400 类似，也是一个通 用的错误码，服务器究竟发生了什么错误我们是不知道的。</span></span></p></div><div id="https://www.notion.so/66e8b49ef3994c8ca2323bcb998978e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		502 Bad Gateway通常是服务器作为网关或者代理时 返回的错误码，表示服务器自身工作正常，访问后端服务器 时发生了错误，但具体的错误原因也是不知道的。</span></span></p></div><div id="https://www.notion.so/980b4aebecdb4ad0ba1aa80cb96d9b6c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		503 Service Unavailable表示服务器当前很忙，暂时 无法响应服务，我们上网时有时候遇到的“网络服务正忙， 请稍后重试”的提示信息就是状态码 503。</span></span></p></div><div id="https://www.notion.so/129cbce8be804a9ba7b4b8fc45cec036" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用 域名“</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://www.apple.com/">www.apple.com</a></span><span class="SemanticString">”访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议 开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间 有缓存，可能不会费太多时间就能拿到结果。 别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一 脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而 不是目标网站的实际地址。 因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不 需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</span></span></p></div><div id="https://www.notion.so/cfcd113a18e54ec3b6aea03889fd6f14" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">http传输大文件的方法</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/d3d7b39ff147403c901c2b2ac8501dea" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">压缩 HTML 等文本文件是传输大文件最基本的方法；</span></span></li><li id="https://www.notion.so/33c483cb7c1f40d7b6dc285c5e321472" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">分块传输可以流式收发数据，节约内存和带宽，使用响应 头字段“Transfer-Encoding: chunked”来表示，分块 的格式是 16 进制长度头 + 数据块</span></span></li><li id="https://www.notion.so/3780ed047a604052be536703aa9235bc" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">范围请求可以只获取部分数据，即“分块请求”，实现视 频拖拽或者断点续传，使用请求头字段“Range”和响应 头字段“Content-Range”，响应状态码必须是 206</span></span></li><li id="https://www.notion.so/fd7ad875a11f43c08f8ebbaa766c15e2" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">也可以一次请求多个范围，这时候响应报文的数据类型 是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。</span></span></li></ol><div id="https://www.notion.so/e22249010aa0480d923379b1fbb1f0c5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">连接管理</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/eb985708e7f3475187abf87d3e439203" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</span></span></li><li id="https://www.notion.so/ccdb827b0c2043de9f571e72902b3ffa" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</span></span></li><li id="https://www.notion.so/077e5cf0840c4105a7c9c2586df92da3" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">服务器会发送“Connection: keep-alive”字段表示启用了长连接；</span></span></li><li id="https://www.notion.so/0fead74791ba4e6b8f6f0a0ccab19026" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">报文头里如果有“Connection: close”就意味着长连接即将关闭；</span></span></li><li id="https://www.notion.so/71d0b3e31fb74b9cac7d1bfd75be273e" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</span></span></li><li id="https://www.notion.so/12b8d71b277342d39aa2e26d937b2c6a" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">“队头阻塞”问题（一个长连接中推积太多请求）会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</span></span></li></ol><div id="https://www.notion.so/ba19ee71c9a848adad43603cafea093f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HTTP管线化</strong></span></span></p></div><div id="https://www.notion.so/ab20f060187748b08a30fbfecd1dce03" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HTTP管线化是将多个HTTP要求（request）整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过永久连接（persistent connection）完成，仅HTTP/1.1支持此技术（HTTP/1.0不支持），并且只有GET和HEAD要求可以进行管线化，而POST则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">管线化并没有解决队头阻塞的问题。</strong></span></span></p></div><div id="https://www.notion.so/3501d80b9e504e4591661c769b95bfbf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">浏览器将HTTP要求大批提交可大幅缩短页面的加载时间，特别是在传输延迟（lag/latency）较高的情况下（如卫星连接）。此技术之关键在于多个HTTP的要求消息可以同时塞入一个TCP分组中，所以只提交一个分组即可同时发出多个要求，借此可减少网络上多余的分组并降低线路负载。</span></span></p></div><h3 id="https://www.notion.so/b9f838b80a52444693fb4541162408f1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b9f838b80a52444693fb4541162408f1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">http2.0</span></span></h3><div id="https://www.notion.so/6af7073cb57a4d04bb196ca4f94135c1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">头部压缩、Server Push、多路复用</span></span></p></div><div id="https://www.notion.so/90353b15ee2d4642aaefeec82192fecb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">头部压缩：HTTP2.0会对HTTP的头进行一定的压缩，将原来每次都要携带的大量key value在两端建立一个索引表，对相同的头只发送索引表中的索引</span></span></p></div><div id="https://www.notion.so/6f913124aa6f4cac906f134400582fc8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Server Push：服务端可以推送消息给客户端</span></span></p></div><div id="https://www.notion.so/3a65b9e87c044b8ea9bc9c5dd1805c3e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多路复用：HTTP2.0协议将一个TCP的连接中，切分成多个流。每个流都有自己的ID，而且流可以是客户端发服务端，也可以是服务端发客户端，它其实只是一个虚拟的通道。流是有优先级的。</span></span></p></div><div id="https://www.notion.so/ee7c2acc86584523af2fb2086f960057" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HTTP2.0还将所有的传输信息分割为更小的信息和帧，并对它们采用二进制格式编码。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流，再就是Data帧，用来传输正文实体。多个Data帧属于一个流</span></span></p></div><div id="https://www.notion.so/99d219e9fc794cd79f193ec1992990ee" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">连接、流和帧的关系</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/672b802ea242497894dedd4ea18b56f7" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">一个连接同时被多个流复用；</span></span></li><li id="https://www.notion.so/bb0ccb65a8fd49d488aa366b6a88fa54" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">一个流代表一次完整的请求/响应过程，包含多个帧；</span></span></li><li id="https://www.notion.so/aaf1cc1dbbdb4a34bea2da310f86008a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">一个消息被拆分封装成多个帧进行传输；</span></span></li></ol><div id="https://www.notion.so/0cf31d927ca6453380867a961ba6382a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">存在的问题</strong></span></span></p></div><div id="https://www.notion.so/9aabb2a5ac934a17881c95a798756093" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HTTP2.0 也是基于TCP协议的，tcp协议在处理包时是有严格顺序的</span></span></p></div><div id="https://www.notion.so/fc7730daac6f4d27bb47c503bd1b6a99" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当其中一个数据包遇到问题，TCP连接需要等待找个包完成重传之后才能继续进行，虽然HTTP2.0通过多个stream，使得逻辑上一个tcp连接上的并行内容，进行多路数据的传输，然而这中间没有关联的数据，一前一后，前面stream2的帧没有收到，后面stream1的帧也会因此堵塞。</span></span></p></div><h3 id="https://www.notion.so/716750dca72a432eaeda99a80912ebe9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/716750dca72a432eaeda99a80912ebe9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">QUIC协议</span></span></h3><div id="https://www.notion.so/98eb39147b9c48d3bcda0d8f4b15e848" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">google的 QUIC协议从TCP切换到UDP</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8868f3db39614e7bbae9e1838d2fdfe4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">机制一：自定义连接机制
一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</span></span><div id="https://www.notion.so/3b68375af78d4255b009b321665dbd92" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接；</span></span></p></div></li><li id="https://www.notion.so/36e00b2654db41a1801a4f5c4417679c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">机制二：自定义重传机制
tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</span></span><div id="https://www.notion.so/8200cd1421ea41f38f307af151612753" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</span></span></p></div><div id="https://www.notion.so/c122b0192bfd473187f0a7e223de5b94" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</span></span></p></div><div id="https://www.notion.so/b97e5f68380d46c69ab27ae8c7822e93" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">QUIC也有个序列号，是递增的，任何序列号的包只发送一次，下次就要加1，那样就计算可以准确了</span></span></p></div><div id="https://www.notion.so/9b160e93ac6943af890411f8f0cf8bc9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</span></span></p></div></li><li id="https://www.notion.so/0be5a18293224bb88af2bae91a55d376" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">机制三： 无阻塞的多路复用</span></span><div id="https://www.notion.so/7cc06a309cd5459092db2c7764addb68" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</span></span></p></div><div id="https://www.notion.so/40b2c92ed5e24564b909aba9ed3677a7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</span></span></p></div></li><li id="https://www.notion.so/6063420c909a4c4187e7af6e82f97605" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">机制四：自定义流量控制</span></span><div id="https://www.notion.so/18c8d370d27b4bcf90151cbfcae39043" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</span></span></p></div><div id="https://www.notion.so/82e47c46694043d1ab7a7d2330b10824" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">因为TCP的ACK机制是基于序列号的累计应答</strong></span><span class="SemanticString">，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</span></span></p></div><div id="https://www.notion.so/c2c9c02ac89b4716aed0cbf78f19214f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。</span></span></p></div></li></ul><h3 id="https://www.notion.so/ccd0e9bddfe84fde99c858e498c9a4ca" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ccd0e9bddfe84fde99c858e498c9a4ca"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">https</span></span></h3><div id="https://www.notion.so/5e9b7300aa5f47cd8ce43f1667cab2e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">非对称加密：RSA</span></span></p></div><div id="https://www.notion.so/b2ba03b4fe72481b99c1be9b3c233b68" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对称加密：AES</span></span></p></div><div id="https://www.notion.so/e8481fffeba04f78a2a35bd96b90ad54" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">摘要算法：SHA2系列</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/b6df3dcfb6f6429d9cb9afa2a7328206" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">客户端使用URL访问web服务器，要求与服务器建立SSL链接（SSL之间的握手协议可以查看其他资料）。</span></span></li><li id="https://www.notion.so/8829d0f045644ba2af6acac014f3b9ce" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">服务器收到客户端的请求后，会将网站的SSL证书信息（包含公钥）传送一份给客户端。</span></span></li><li id="https://www.notion.so/8f677b184aa54a37b082aab2d74fc719" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">客户端开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书进行比对。如果没找到该CA的信息，浏览器会提示不信任网站的信息。</span></span></li><li id="https://www.notion.so/e8a08158c8814acaa0fdd4d7fd6d542e" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">如果找到，浏览器从操作系统中取出颁发者CA的公钥将证书中的签名进行解密，对服务器进行认证，防止服务器是被冒充的。</span></span></li><li id="https://www.notion.so/5aba928f1b434b50a8f832123e7fde32" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">一切没问题后，浏览器与服务器进行加密等级等内容进行协商产生一个对称的密钥，然后通过接受到的证书中的公钥对这个对称密钥进行加密，传送给服务器。</span></span></li><li id="https://www.notion.so/8daa6640e42b47dcbae8ecdc08e0a650" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">服务器拿到信息后用自己的私钥进行解密拿到对称密钥。于是客户端和服务器就可以通过这个对称密钥进行安全且快乐的对话了。</span></span></li></ol><div id="https://www.notion.so/ddda0af591f745a8a149987ebfa8e6ab" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">证书的签发过程</strong></span></span></p></div><div id="https://www.notion.so/7e0effbd5cec4f49be12a1db4891319a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">a.服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；</span></span></p></div><div id="https://www.notion.so/dbb704cc5dd6439dbb319f9c0bd3d325" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://b.ca/">b.CA</a></span><span class="SemanticString"> 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；</span></span></p></div><div id="https://www.notion.so/f38e9b7bb52b479da3b4bc5dd69a8f3c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">c.如信息审核通过，CA 会向申请者签发认证文件-证书。</span></span></p></div><div id="https://www.notion.so/d5929e30f6844657a033f6d0a70effd7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">			证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；</span></span></p></div><div id="https://www.notion.so/6c9ed94f52a04e259ba7ddf35d820e5b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">			签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；</span></span></p></div><div id="https://www.notion.so/52fe55a31ea848b9a1f8039a7aaa93c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">d.客户端 C 向服务器 S 发出请求时，S 返回证书文件；</span></span></p></div><div id="https://www.notion.so/9c493cfffd5b48bea7c38a0545b53665" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">e.客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；</span></span></p></div><div id="https://www.notion.so/656f6416e22040acb7a0897711b562e7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">f.客户端然后验证证书相关的域名信息、有效时间等信息；</span></span></p></div><div id="https://www.notion.so/e6ec84ae03f74661874787421118122c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">g.客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</span></span></p></div><h2 id="https://www.notion.so/a612018f85f94a3fa12a831e5142f63e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a612018f85f94a3fa12a831e5142f63e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">其他协议</span></span></h2><h3 id="https://www.notion.so/e69f8667b1c14b60972a2a7d0d950680" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e69f8667b1c14b60972a2a7d0d950680"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">FTP</span></span></h3><div id="https://www.notion.so/c15d90f054dd4b10b14f1ebabb3a5697" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">FTP（文件传输协议）</strong></span><span class="SemanticString">。FTP 采用两个 TCP 连接来传输一个文件。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/b255eb7d595048b19f677efd5c4d911a" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">控制连接</strong></span><span class="SemanticString">。服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">命令</strong></span><span class="SemanticString">从客户端传给服务器，并传回服务器的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">应答</strong></span><span class="SemanticString">。常用的命令有：lsit - 获取文件目录，reter - 取一个文件，store - 存一个文件；</span></span></li><li id="https://www.notion.so/41547e816aae4e939262d33e11de56b7" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">数据连接</strong></span><span class="SemanticString">。每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。</span></span></li></ol><div id="https://www.notion.so/bbce9d59a92342e79762c6859df49654" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">FTP 的工作模式</strong></span></span></p></div><div id="https://www.notion.so/e37833ed86c143ebabb6dd22f136c89e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 FTP 的两个 TCP 连接中，每传输一个文件，都要新建立一个数据连接。基于这个数据连接，FTP 又有两种工作模式：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主动模式（PORT）</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">和</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">被动模式（PASV）</strong></span><span class="SemanticString">，要注意的是，这里的主动和被动都是站在服务器角度来说的。工作模式过程如下：</span></span></p></div><div id="https://www.notion.so/add0b01b609843a7b5645eeef01d72ff" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主动模式工作流程</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/0069334660db40e5a0f7eb7336032944" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">客户端随机打开一个大于 1024 的端口 N，向服务器的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">命令端口 21</strong></span><span class="SemanticString"> 发起连接，同时开放 N+1 端口监听，并向服务器发出“port N+1” 命令；</span></span></li><li id="https://www.notion.so/c679c4e40b514a00b4a32fd681dc40d0" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">由服务器从自己的数据端口 20，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主动连接到客户端指定的数据端口 N+1</strong></span><span class="SemanticString">。</span></span></li></ol><div id="https://www.notion.so/617d3ca34c4242b697ccee85919958cb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">被动模式工作流程</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/7d4b61c582a44e68b1f554ffab1a68d3" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">客户端在开启一个 FTP 连接时，打开两个任意的本地端口 N（大于1024）和 N+1。然后用 N 端口连接服务器的 21 端口，提交 PASV 命令；</span></span></li><li id="https://www.notion.so/b5babb03612c4d7f96b6f043bf943bf8" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">服务器收到命令，开启一个任意的端口 P（大于 1024），返回“227 entering passive mode”消息，消息里有服务器开放的用来进行数据传输的端口号 P。</span></span></li><li id="https://www.notion.so/7b365b3a0d964578bd2c8db0b440b311" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">客户端收到消息，取得端口号 P，通过 N+1 端口连接服务器的 P 端口，进行数据传输。</span></span></li></ol><h3 id="https://www.notion.so/6a05cfb58bc645458142e7a6b8d2b945" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6a05cfb58bc645458142e7a6b8d2b945"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">p2p</span></span></h3><div id="https://www.notion.so/ce51a7ad3e1046009afbec5fe448a51a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">		</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">赖于 Tracker 的，也就是元数据集中，文件数据分散。</strong></span></span></p></div><div id="https://www.notion.so/cba8f2ff7ac24475a14d9178722acf3c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">P2P 就是 peer-to-peer。这种方式的特点是，资源一开始并不集中存储在某些设备上，而是分散地存储在多台设备上，这些设备我们称为 peer。</span></span></p></div><div id="https://www.notion.so/3e9b84604c2d4e7eb6e16a019ec1aca7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在下载一个文件时，只要得到那些已经存在了文件的 peer 地址，并和这些 peer 建立点对点的连接，就可以就近下载文件，而不需要到中心服务器上。一旦下载了文件，你的设备也就称为这个网络的一个 peer，你旁边的那些机器也可能会选择从你这里下载文件。</span></span></p></div><div id="https://www.notion.so/ac04e771e8164469a943a8723f0e114c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通过这种方式解决上面 C/S 结构单一服务器带宽压力问题。如果使用过 P2P2 软件，例如 BitTorrent，你就会看到自己网络不仅有下载流量，还有上传流量，也就是说你加入了这个 P2P 网络，自己可以从这个网络里下载，同时别人也可以从你这里下载。这样就实现了，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">下载人数越多，下载速度越快的愿望</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/1f1c557d0a5f4f788eaab8e42fbff479" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">种子文件（.torent）</strong></span></span></p></div><div id="https://www.notion.so/df50fc9b6f374f918562bf72521505cc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上面整个过程是不是很完美？是的，结果很美好，但为了实现这个美好，我们还是有很多准备工作要做的。比如，我们怎么知道哪些 peer 有某个文件呢？</span></span></p></div><div id="https://www.notion.so/c7b6c88a34554597a05b9c27620a8599" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这就用到我们常说的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">种子（.torrent）</strong></span><span class="SemanticString">。 .torrent 文件由</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Announce（Tracker URL）</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">和</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">文件信息</strong></span><span class="SemanticString">两部分组成。</span></span></p></div><div id="https://www.notion.so/02de867541564947b771ae232a6d7ba8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其中，文件信息里有以下内容：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/5420a64e8e2545b98a9ee24d7d992d3b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Info 区</strong></span><span class="SemanticString">：指定该种子包含的文件数量、文件大小及目录结构，包括目录名和文件名；</span></span></li><li id="https://www.notion.so/b55ca0117a12421d95f1754e4cbe9ec1" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Name 字段</strong></span><span class="SemanticString">：指定顶层目录名字；</span></span></li><li id="https://www.notion.so/7b2ecb122d954aa987fa4d634dd2ebeb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">每个段的大小</strong></span><span class="SemanticString">：BitTorrent（BT）协议把一个文件分成很多个小段，然后分段下载；</span></span></li><li id="https://www.notion.so/0856629b4e0d4f2382b1fbb9ea54e004" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">段哈希值</strong></span><span class="SemanticString">：将整个种子种，每个段的 SHA-1 哈希值拼在一起。</span></span></li></ul><div id="https://www.notion.so/98d2b01c37f04fdab2a8cda3c81ec64b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下载时，BT 客户端首先解析 .torrent 文件，得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。</span></span></p></div><div id="https://www.notion.so/5c49bd789241458cabaf5e6522cc4e88" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下载者再连接其他下载者，根据 .torrent 文件，两者分别对方自己已经有的块，然后交换对方没有的数据。</span></span></p></div><div id="https://www.notion.so/bf32b61c28a447a8a04c2c12fa032654" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以看到，下载的过程不需要其他服务器参与，并分散了单个线路上的数据流量，减轻了服务器的压力。</span></span></p></div><div id="https://www.notion.so/3545d1951d544fa5b8318e66bb5b20c2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下载者每得到一个块，需要算出下载块的 Hash 验证码，并与 .torrent 文件中的进行对比。如果一样，说明块正确，不一样就需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。</span></span></p></div><div id="https://www.notion.so/f98aca88f78942b5b08ab6cfe4391a9b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从这个过程也可以看出，这种方式特别依赖 Tracker。Tracker 需要收集所有 peer 的信息，并将从信息提供给下载者，使下载者相互连接，传输数据。虽然下载的过程是非中心化的，但是加入这个 P2P 网络时，需要借助 Tracker 中心服务器，这个服务器用来登记有哪些用户在请求哪些资源。</span></span></p></div><div id="https://www.notion.so/a8d6c713eabc4483a28aa15a0ce3f51c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，这种工作方式有一个弊端，一旦 Tracker 服务器出现故障或者线路被屏蔽，BT 工具就无法正常工作了。那能不能彻底去中心化呢？答案是可以的。</span></span></p></div><h3 id="https://www.notion.so/af1dd9072bf741358cbb646d6e5db102" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/af1dd9072bf741358cbb646d6e5db102"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">DHT(</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Distributed Hash Table</strong></span><span class="SemanticString">)</span></span></h3><div id="https://www.notion.so/a361ad9b900942c3ac8c602d4d1d2034" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">去中心化网络</span></span></p></div><div id="https://www.notion.so/b3ec8ae656f642f2b017fe31bc1c8bad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DHT（Distributed Hash Table）</strong></span><span class="SemanticString">，这个网络中，每个加入 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。</span></span></p></div><div id="https://www.notion.so/5523e34845a047f78c08b3c612d3f3a7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">而 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Kedemlia 协议</strong></span><span class="SemanticString"> 就是一种著名的 DHT 协议。我们来基于这个协议来认识下这个神奇的 DHT 网络。</span></span></p></div><div id="https://www.notion.so/70f2c6be6d254eaa9293dc40a8f78165" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当一个客户端启动 BitTorrent 准备下载资源时，这个客户端就充当了两个角色：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/4dfccba1e8fd4596bb81e417e6c6ccda" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">peer 角色：监听一个 TCP 端口，用来上传和下载文件。对外表明我这里有某个文件；</span></span></li><li id="https://www.notion.so/6df4a5c0f26e4502bdd7d4b5e664e523" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">DHT Node 角色：监听一个 UDP 端口，通过这个角色，表明这个节点加入了一个 DHT 网络。</span></span></li></ol><div id="https://www.notion.so/dc057ab8752c4b1f85ca5ae83ed58d16" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 DHT 网络里面，每一个 DHT Node 都有一个 ID。这个 ID 是一个长字符串。每个 DHT Node 都有责任掌握一些“知识”，也就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">文件索引</strong></span><span class="SemanticString">。也就是说，每个节点要知道哪些文件是保存哪些节点上的。注意，这里它只需要有这些“知识”就可以了，而它本身不一定就是保存这个文件的节点。</span></span></p></div><div id="https://www.notion.so/8f2705ee02d049d9a2a06abf1eeccd4e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当然，每个 DHT Node 不会有全局的“知识”，也就是说它不知道所有的文件保存位置，只需要知道一部分。这里的一部分，就是通过哈希算法计算出来的。</span></span></p></div><h3 id="https://www.notion.so/f46a451773bf4de4b6ed7a8fe26fee30" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f46a451773bf4de4b6ed7a8fe26fee30"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Node ID 和文件哈希值</span></span></h3><div id="https://www.notion.so/1492e3239b8045c4bcd6a53e172da595" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个文件可以计算出一个哈希值，而 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DHT Node 的 ID 是和哈希值相同长度的串</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/61814dccdce24831a9f9dd857a6cdbf5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于文件下载，DHT 算法是这样规定的：</span></span></p></div><blockquote id="https://www.notion.so/8993fd56e1af4b5faa340fabd1cd0297" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">如果一个文件计算出一个哈希值，则和这个哈希值一样的那个 DHT Node，就有责任知道从哪里下载这个文件，即便它自己没保存这个文件。</span></span></blockquote><div id="https://www.notion.so/7c27fcd599df4aed86c2e6c61b635869" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当然不一定总这么巧，都能找到和哈希值一模一样的，有可能文件对应的 DHT Node 下线了，所以 DHT 算法还规定：</span></span></p></div><blockquote id="https://www.notion.so/e6e57617f87a4113beca6ef662ece2a3" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">除了一模一样的那个 DHT Node 应该知道文件的保存位置，ID 和这个哈希值非常接近的 N 个 DHT Node 也应该知道。</span></span></blockquote><div id="https://www.notion.so/69638340f8a44aa28e83d80bbc976478" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">DHT 一种是基于分布式的哈希算法，元数据和文件数据全部分散。</span></span></p></div><h3 id="https://www.notion.so/23016e7c21eb4821b1b04ee10fd1bab3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/23016e7c21eb4821b1b04ee10fd1bab3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">DNS</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/3448229c44c34ede893824b2ddc078b1" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">客户端先查找 当前浏览器缓存-&gt; 操作系统/etc/hosts文件 -&gt; 本地DNS缓存</strong></span></span></li><li id="https://www.notion.so/ad21ab5daeee47969c307ab96f34297e" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">客户端发出 DNS 请求给本地域名服务器</strong></span><span class="SemanticString">。我们访问博客园，客户端会问本地域名服务器， </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://www.cnblogs.com/">www.cnblogs.com</a></span><span class="SemanticString"> 的 IP 是什么？（本地域名服务器，如果网络是通过 DHCP 配置，本地 DNS 是由你的网络服务商，如电信、联通等自动分配，它通常就在网络服务商的机房里）；</span></span></li><li id="https://www.notion.so/db446478e28747c989ec610835890dab" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地 DNS 收到来自客户端的请求，查找“地址簿”，返回 IP 或请求根域名服务器</strong></span><span class="SemanticString">。我们可以理解为服务器上缓存了一张域名与 IP 对应的大表，如果能找到 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://www.cnblogs.com/">www.cnblogs.com</a></span><span class="SemanticString">，就直接返回对应的 IP 地址。如果没有找到，本地 DNS 会去问它的根域名服务器；</span></span></li><li id="https://www.notion.so/3aa37bb513074f34aee0e826463d01e0" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">根 DNS 收到来自本地 DNS 的请求，返回 .com 对应的顶级域名服务器的地址</strong></span><span class="SemanticString">。根域名服务器是最高层次的，全球共有 13 套，它不直接用于域名解析，而是指明怎样去查找对应 IP。它发现请求的域名后缀是 .com，就会返回 .com 对应的顶级域名服务器的地址；</span></span></li><li id="https://www.notion.so/a6d643d51e734aff96f8f68afd328669" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地 DNS 服务器收到顶级 DNS 服务器地址，请求顶级 DNS 服务器查询域名 IP</strong></span><span class="SemanticString">；</span></span></li><li id="https://www.notion.so/451dbcf2495a47fcab4bed197d018c59" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">顶级 DNS 服务器返回权威 DNS 服务器地址</strong></span><span class="SemanticString">。顶级域名服务器就是大名鼎鼎的，负责 .com、.net、.org 这些二级域名，比如 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://cnblogs.com/">cnblogs.com</a></span><span class="SemanticString">，它会返回对应的权威 DNS 服务器地址；</span></span></li><li id="https://www.notion.so/68f3b5be300948e5a37154ee8f5dcb42" class="NumberedList" value="7"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地 DNS 服务器收到权威 DNS 服务器地址，请求权威 DNS 服务器查询域名 IP</strong></span><span class="SemanticString">。而 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://cnblogs.com/">cnblogs.com</a></span><span class="SemanticString"> 的权威 DNS 服务器就是域名解析结果的原出处；</span></span></li><li id="https://www.notion.so/0518a3c46269439b82509fd2dfa2f0bc" class="NumberedList" value="8"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">权威 DNS 服务器返回对应 IP</strong></span><span class="SemanticString">。权威 DNS 服务器查询“地址簿”，获取到域名对应 IP 地址，返回给本地 DNS 服务器；</span></span></li><li id="https://www.notion.so/5a73920f828b4d9db0138536d5905352" class="NumberedList" value="9"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地 DNS 服务器收到 IP，返回给客户端</strong></span><span class="SemanticString">；</span></span></li><li id="https://www.notion.so/23a9c9f1c64d41b2aee9a6802bf1c78c" class="NumberedList" value="10"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">客户端与目标建立连接</strong></span><span class="SemanticString">。</span></span></li></ol><div id="https://www.notion.so/c10856d0ccab451f94c7a8eed5faaab5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">DNS还可以做负载均衡</span></span></p></div><h3 id="https://www.notion.so/dd337952868c4ad887057c227932e3a6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/dd337952868c4ad887057c227932e3a6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">CDN</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/fcd1c4bb3a4d484f8ef676ebd45a9e3e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，从而将数据缓存在离用户最近的位置。</span></span></li><li id="https://www.notion.so/d8d7172ed15342f2925ef0e59a9f3731" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">CDN 最擅长的缓存是缓存静态数据。除此之外还可以缓存流媒体数据。这时候要注意防盗链问题。它也支持动态数据的缓存，一种是边缘计算，另一种是链路优化。</span></span></li></ul></article>
  <footer class="Footer">
  <div>&copy; 夕的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>