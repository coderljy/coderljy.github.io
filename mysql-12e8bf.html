<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Mysql详解&nbsp;|&nbsp;夕的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Mysql详解">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Mysql详解</h1>
    
  </header>
  <article id="https://www.notion.so/12e8bf8403664688998b2f2a1e496ec4" class="PageRoot"><h2 id="https://www.notion.so/349d976180a8411bb3e1be5105c84a98" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/349d976180a8411bb3e1be5105c84a98"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Mysql逻辑结构</span></span></h2><div id="https://www.notion.so/60e1386cd417444b947203bcb390d886" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="notion://www.notion.so/coder-x/Mysql%E8%AF%A6%E8%A7%A3.md">Mysql详解.md</a></span></span></p></div><h3 id="https://www.notion.so/ff827d0dd1e4462bb49f78d73242a3d5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ff827d0dd1e4462bb49f78d73242a3d5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">长连接 and 短连接</span></span></h3><div id="https://www.notion.so/cc0d05f20c774d4ebe5ecdec03906897" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、什么是长链接？</strong></span><span class="SemanticString">
数据库里面，长连接是连接成功后，如果客户端持续有请求，则一直使用同一个链接。</span></span></p></div><div id="https://www.notion.so/d1170fc6d0164cc2b4a4342b2aef48b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、什么是短连接？</strong></span><span class="SemanticString">
短连接则是指每次执行完很少的几次查询就断开连接，下次查询重新建立一个</span></span></p></div><div id="https://www.notion.so/8c74e3c04ee74e12a8206848c954fadb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3、尽量使用长链接</strong></span><span class="SemanticString">
建立连接的过程通常是比较复杂的，所以我建议你在使用中尽量减少建立的动作，也就是使用长连接。</span></span></p></div><h3 id="https://www.notion.so/33eaf49b7c6845e9954201ccaebf7215" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/33eaf49b7c6845e9954201ccaebf7215"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">长连接的缺点和解决方案</span></span></h3><div id="https://www.notion.so/c013dfb5ad3445aaaf37f0eb57a36561" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、为什么MySQL占用内存涨得特别快</strong></span><span class="SemanticString">
但是全部是用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，</span></span></p></div><div id="https://www.notion.so/2d6e6577aa334ba983df36eb1e58e325" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这是因为MySQL在执行过程中临时使用的内存管理在连接对象里面的，这些资源会在连接断开的时候才释放，</span></span></p></div><div id="https://www.notion.so/b625e325d9174f619ef032e12a013583" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以如果长链接积累下来，可能导致内存占用大，被系统强行杀掉，从现象看就是MySQL异常重启了</span></span></p></div><div id="https://www.notion.so/ee11cc384d3642a09af9cd16c9cf9165" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、如何解决MySQL占用内存涨得特别快</strong></span><span class="SemanticString">
1、定期断开长链接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再连接</span></span></p></div><div id="https://www.notion.so/d65eb5fb459244d3a65ea8220020a855" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2、如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">mysql_reset_connection</strong></span><span class="SemanticString">来重新初始化连接资源，这个过程不需要重连或重新做权限验证，但是会将连接回复到刚刚创建完时的状态；</span></span></p></div><h3 id="https://www.notion.so/826c4b6bf9e342fdad0bccd5d353c28c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/826c4b6bf9e342fdad0bccd5d353c28c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">查询缓存</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/912cce388b994f9eac4811e8e2436e31" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，如果有，就直接返回给客户端</span></span></li><li id="https://www.notion.so/0ddb5f97ce5841dd8151a4eb9fec0ead" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">如果语句不在查询缓存中，就会继续后面的执行阶段。</span></span></li><li id="https://www.notion.so/97cabcefa8f04839b1b00c268f104b93" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">执行完成后，执行结果会被存入查询缓存中，</span></span></li><li id="https://www.notion.so/bb83aad6fc0a4efc9be9de13fd046975" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">如果查询命中缓存MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高</span></span></li></ol><div id="https://www.notion.so/bcb2832b84fe44dc8cb5dca86b0cad6c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么大多数情况下不建议使用查询缓存？</strong></span></span></p></div><div id="https://www.notion.so/5f69dbb4980a4ef08d95e7e1262d19fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">1、查询缓存的失效非常频繁，只要有一个表更新，这个表上所有的查询缓存都被清空
2、对于更新压力大的数据库来说，查询缓存的命中率会非常低，
3、除非你的业务就是有一张静态表，很长时间才会更新一次(比如一个系统配置表)</span></span></p></div><div id="https://www.notion.so/269ff9ee4b1f4169ab3c7d91512f05fd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、默认语句不实用查询缓存</strong></span></span></p></div><div id="https://www.notion.so/eae526794502462aa8e6bf3b29f6e7cc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL提供的按需使用的方式</span></span></p></div><pre id="https://www.notion.so/d0185c1deceb4db4841da527333e2ca3" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>query_cache_type 设置成 DEMAND
</span></span></span></code></pre><div id="https://www.notion.so/dca0d4f22cab4af897bab1a428d9903a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、确定需要查询缓存的语句</strong></span></span></p></div><pre id="https://www.notion.so/7c11d3c2f1bf4c21bb99866c8e203edf" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>mysql&gt; select SQL_CACHE * from T where ID=10；
</span></span></span></code></pre><h3 id="https://www.notion.so/763c246fce604a7d98eb4d3f3db85a08" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/763c246fce604a7d98eb4d3f3db85a08"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">优化器</span></span></h3><div id="https://www.notion.so/ff540f7f582943e19435876136b0d388" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、优化器的作用</strong></span><span class="SemanticString">
1、在表里面有多个索引的时候，决定使用哪个索引</span></span></p></div><div id="https://www.notion.so/e0d3fa3eec864f69b3299f0e111b3f94" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2、多表关联(ioin)的时候，决定各个表的链接顺序</span></span></p></div><div id="https://www.notion.so/d462265880624b2a9c2e4b628f73e3b4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、举例说明</strong></span></span></p></div><pre id="https://www.notion.so/6b21faedbda04a3abe5508fc75865a09" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
</span></span></span></code></pre><div id="https://www.notion.so/54ccfd911390410b9dbdcb08155735d7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于20
也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于10</span></span></p></div><div id="https://www.notion.so/508dff6268d143a2879b7ef90dce6e6e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这两种执行方法的逻辑结果时一样的，但是执行的效率会有不同，而优化器的作用就是决定选择哪一个方案</span></span></p></div><h3 id="https://www.notion.so/695e599aa89f4f969caddff4b1ab5c04" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/695e599aa89f4f969caddff4b1ab5c04"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">执行器</span></span></h3><div id="https://www.notion.so/0db70c8899494bb5963bb63af8454973" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、没有索引的执行流程</strong></span><span class="SemanticString">
1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中
2、调用引擎接口取&quot;下一行&quot;，重复相同的判断逻辑，直到取到这个表的最后一行
3、执行器将上述遍布过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</span></span></p></div><div id="https://www.notion.so/bca8c6a0870d422783a3b396e789e480" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、有索引的执行流程</strong></span><span class="SemanticString">
第一调用的是&quot;取满足条件的第一行&quot;这个接口，
之后循环取&quot;满足条件的下一行&quot;</span></span></p></div><h2 id="https://www.notion.so/28c2c330e0b64e028f0f8f932aa727f0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/28c2c330e0b64e028f0f8f932aa727f0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">日志系统</span></span></h2><div id="https://www.notion.so/c1349635b6204fdaaddf54b7418423d1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</strong></span></span></p></div><h3 id="https://www.notion.so/453f63748acb4945aac35ae8c6da6c46" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/453f63748acb4945aac35ae8c6da6c46"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">undo日志</span></span></h3><div id="https://www.notion.so/55aba85fb3f64331bbd5874e8eb1b57d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Undo Log 是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)。</span></span></p></div><div id="https://www.notion.so/9e28eada1a614b6a85622f9dd0b3f25d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。
除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</span></span></p></div><div id="https://www.notion.so/59ea4645f2a34f1195f3c92b0be4915e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">缺点</strong></span></span></p></div><div id="https://www.notion.so/877d25988a1943a79a177d5e4671b122" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果每个事务提交前都将数据和undo log写入磁盘(undo log的写入一定先于数据，因为保证undo log完整可以用来回滚事务)，这样会导致大量磁盘IO，因此性能很低；如果将数据缓存一段时间，这样会丧失持久性。所以出现了redolog.</span></span></p></div><h3 id="https://www.notion.so/2a8a502c423f43ea82a04be18e40dbfa" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2a8a502c423f43ea82a04be18e40dbfa"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">redo log</span></span></h3><div id="https://www.notion.so/dc8072ff12c0405f84d2ccf52e30e5fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果每一次更新操作都需要写进磁盘，然后磁盘找到对应的那条数据，然后在更新，整个过程的IO成本，查找成本都很高。为了解决这个问题，mysql使用WAL（WriteAhead Logging，预写式日志）：先写日志，再写磁盘；</span></span></p></div><div id="https://www.notion.so/33821bdc670e48ab9065a6ee80c5c5bd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redo log是位于mysql引擎层的（mysql大体分为server层和引擎层），并且其大小是固定的，可以循环写入（使用双指针保证可写入位置，write pos是当前记录的位置，一边写一边后移；checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文 件）</span></span></p></div><div id="https://www.notion.so/f9a11ac98b8c41a6b3f5e59efd98f513" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redo log保证了mysql具有crash-safe（崩溃安全）能力，</span></span></p></div><div id="https://www.notion.so/1ea5612eeed94d589e03d3000b8edc80" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">保证redo log能够有比较好的IO性能</strong></span></span></p></div><div id="https://www.notion.so/11c3839056af4e5e90bba43f080ac710" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">A. 尽量保持Redo Log存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。
B. 批量写入日志。日志并不是直接写入文件，而是先写入redo log buffer.当需要将日志刷新到磁盘时(如事务提交),将许多日志一起写入磁盘.
C. 并发的事务共享Redo Log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的：
记录1: &lt;trx1, insert …&gt;
记录2: &lt;trx2, update …&gt;
记录3: &lt;trx1, delete …&gt;
记录4: &lt;trx3, update …&gt;
记录5: &lt;trx2, insert …&gt;
D. 因为C的原因,当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。
E. Redo Log上只进行顺序追加的操作，当一个事务需要回滚时，它的Redo Log记录也不会从Redo Log中删除掉。</span></span></p></div><h3 id="https://www.notion.so/a4bf81442b4043049bfd13670946a4f6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a4bf81442b4043049bfd13670946a4f6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">undo + redo</span></span></h3><div id="https://www.notion.so/349c68b387ca4ea2b143b6faace4d93f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">流程：</strong></span></span></p></div><div id="https://www.notion.so/77372c1f642c41e39d5232a822214634" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">假设 有A  值为1.</strong></span></span></p></div><div id="https://www.notion.so/847a8f541972470e9883a02386d6692d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">A.事务开始.</strong></span></span></p></div><div id="https://www.notion.so/ca7794579f6041a78f992c28fb623586" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">B.记录A=1到undo log.</strong></span></span></p></div><div id="https://www.notion.so/1fef8ca4c29f4978931e72400d612780" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">C.修改A=3.</strong></span></span></p></div><div id="https://www.notion.so/8f407885e3be4a6192fec790b1de3e0a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">D.记录A=3到redo log.（此时redolog处于prepare状态）</strong></span></span></p></div><div id="https://www.notion.so/99c623efca1449edbd6ab4ce2523c843" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">E.告诉执行器，随时可以提交事务，然后执行器生成这个操作的binlog，并把binlog写入磁盘</strong></span></span></p></div><div id="https://www.notion.so/cec23cf9042f4300a8ceaf81e1dd85fc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">F.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，事务完成。</strong></span></span></p></div><div id="https://www.notion.so/25a1de702f794cf7bd90c3d7fbbd1098" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Undo + Redo事务的特点</strong></span><span class="SemanticString">
A. 为了保证持久性，必须在事务提交前将Redo Log持久化。
B. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。
C. Redo Log 保证事务的持久性。
D. Undo Log 保证事务的原子性。
E. 有一个隐含的特点，数据必须要晚于redo log写入持久存储。</span></span></p></div><h3 id="https://www.notion.so/ce0c3f966c7447548b3c454c967aa0d9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ce0c3f966c7447548b3c454c967aa0d9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">binlog（归档日志）</span></span></h3><div id="https://www.notion.so/0f51d350d8e14a9cb83184b50f47b9c3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">redolog 是InnoDB特有的，是物理日志 ，记录的是“在某个数据页上做了什么修改”；，通过循环写，空间固定会用完；</span></span></p></div><div id="https://www.notion.so/a31fa58ae0724a0bbded9708729d6b7b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">binlog是server层实现，所有引擎都可以使用，逻辑日志，记录原始逻辑，比如“给ID=2这一行的c字段加1 ”；追加写入，不会覆盖以前的日志。只依靠binlog是没有crash-safe能力的。</span></span></p></div><h3 id="https://www.notion.so/2a4215f4fc154055a5229559ddbb5905" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/2a4215f4fc154055a5229559ddbb5905"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">两阶段提交</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/316a22562da64a3c866ccc268fc13e84" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</span></span></li><li id="https://www.notion.so/d47a5b99427449fbaaa14adc218802e4" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</span></span></li><li id="https://www.notion.so/aa34b31a1bcc483aa7db89f890a1f671" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</span></span></li><li id="https://www.notion.so/f0497f5ea3384575894084fd28a815fb" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">执行器生成这个操作的binlog，并把binlog写入磁盘。</span></span></li><li id="https://www.notion.so/b5c44fea90e34e2abf2d9aec7270aa22" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</span></span></li></ol><div id="https://www.notion.so/f85db4d068c948ac9cb70ea88af58995" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不用两阶段提交，会产生什么？</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/274ca9d245894821b5ce8ef7864f5c5e" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">先写redo log后写binlog</strong></span><span class="SemanticString">。假设在redo log写完，binlog还没有写完的时候，MySQL进程异
常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回
来，所以恢复后这一行c的值是1。
但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份
日志的时候，存起来的binlog里面就没有这条语句。
然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这
个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</span></span></li><li id="https://www.notion.so/1ca4cd53c89043ad833f6f6df81d7ec7" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">先写binlog后写redo log</strong></span><span class="SemanticString">。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以
后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日
志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是
1，与原库的值不同。</span></span></li></ol><h2 id="https://www.notion.so/b080be01b20d45299e5bbeec3b20f7c0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/b080be01b20d45299e5bbeec3b20f7c0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">事务</span></span></h2><div id="https://www.notion.so/081f860ebf40449997d56b794281f0b8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">事务的特性</strong></span><span class="SemanticString">：ACID ： 原子性	一致性	隔离性	持久性</span></span></p></div><h3 id="https://www.notion.so/db7d8499627140ada6679f023e54883d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/db7d8499627140ada6679f023e54883d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">事务的隔离级别</span></span></h3><div id="https://www.notion.so/7209b83e80174a8eab8673efc62167e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">串行化：我的事务尚未提交，别人就别想改数据。</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">这4种隔离级别，并行性能依次降低，安全性依次提高。</strong></span></span></p></div><div id="https://www.notion.so/342e1b2854d04bccbd845a7db705fbe1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</span></span></p></div><div id="https://www.notion.so/d8c28987474649cb81c65426411015eb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</span></span></p></div><div id="https://www.notion.so/18d527772b1a43a8961feb39587fb28e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。</span></span></p></div><div id="https://www.notion.so/750affbef38643d9bcf6608de2523f04" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念；</span></span></p></div><div id="https://www.notion.so/d83b7f90e8e14097bf8d5f370a06b233" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。</span></span></p></div><div id="https://www.notion.so/2de2f70e86174a278757a162dd256924" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">默认使用读提交。</strong></span></span></p></div><div id="https://www.notion.so/b038bf11eadc414182ae858feec8884c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、回滚日志什么时候删除？</strong></span></span></p></div><div id="https://www.notion.so/59d04af107c64044b5a7d1a4305f5b30" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除</span></span></p></div><div id="https://www.notion.so/0869b09e2eb542fbbadefafa975230b9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、什么时候不需要了？</strong></span></span></p></div><div id="https://www.notion.so/af86ac423931431c96d52a514878daae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当系统里没有比这个回滚日志更早的read-view的时候。</span></span></p></div><div id="https://www.notion.so/5a787fc0ee7d41b0820dca5d344d9bf5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3、为什么尽量不要使用长事务</strong></span></span></p></div><div id="https://www.notion.so/908d1a19256d4b79987eb9cad7d3709e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</span></span></p></div><h3 id="https://www.notion.so/43c46b70f8c94b88ad0847d654528ec2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/43c46b70f8c94b88ad0847d654528ec2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">恢复策略</span></span></h3><div id="https://www.notion.so/59396c6cd89f4e7bb2c69b81ff75409b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理.</span></span></p></div><div id="https://www.notion.so/4fbe5f43895746ac9641279b75fe78e7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">有2中不同的恢复策略：</span></span></p></div><blockquote id="https://www.notion.so/cca9bc1a39264617a7957f8b0fbdeb61" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">A. 进行恢复时，只重做已经提交了的事务。
B. 进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些
未提交的事务。</span></span></blockquote><div id="https://www.notion.so/586c0ca040174acf932210e412f3a1e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">MySQL数据库InnoDB存储引擎使用了B策略</strong></span></span></p></div><div id="https://www.notion.so/ed0d38f0c4a4426092bd8f4c5f235bf0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB存储引擎中的恢复机制有几个特点：</span></span></p></div><div id="https://www.notion.so/29a5254c5cb94961b47913758c042662" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">A. 在重做Redo Log时，并不关心事务性。</strong></span><span class="SemanticString"> 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。
**B. 使用B策略就必须要将Undo Log持久化，而且必须要在写Redo Log之前将对应的Undo Log写入磁盘。**Undo和Redo Log的这种关联，使得持久化变得复杂起来。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为了降低复杂度，InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中。这样undo log就可以象数据一样缓存起来，而不用在redo log之前写入磁盘了。</strong></span><span class="SemanticString">
包含Undo Log操作的Redo Log，看起来是这样的：
记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;
记录2: &lt;trx1, insert …&gt;
记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;
记录4: &lt;trx2, update …&gt;
记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;
记录6: &lt;trx3, delete …&gt;
C. </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中。</strong></span><span class="SemanticString">
一个回滚了的事务的Redo Log，看起来是这样的：
记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;
记录2: &lt;trx1, insert A…&gt;
记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;
记录4: &lt;trx1, update B…&gt;
记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;
记录6: &lt;trx1, delete C…&gt;
记录7: &lt;trx1, insert C&gt;
记录8: &lt;trx1, update B to old value&gt;
记录9: &lt;trx1, delete A&gt;</span></span></p></div><div id="https://www.notion.so/41b76514973644dfa93a822e2dbc94a6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性.</strong></span></span></p></div><h3 id="https://www.notion.so/0ffab4fce64b45e28459edff5f791cda" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/0ffab4fce64b45e28459edff5f791cda"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">脏读、幻读、不可重复读</span></span></h3><h3 id="https://www.notion.so/0335c0a5e6234dc78638c7723a2bfc75" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/0335c0a5e6234dc78638c7723a2bfc75"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1、脏读：</span></span></h3><div id="https://www.notion.so/5a0d448387ad41ce9985d8cdf903aa52" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，
另一个事务B 来读取了修改后的内容并且使用了，
之后事务A提交了，此时就引起了脏读。</span></span></p></div><div id="https://www.notion.so/c2fd7ad026764e4787b72e339de84e34" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">此情况仅会发生在： 读未提交的的隔离级别.</strong></span></span></p></div><h3 id="https://www.notion.so/d9f5e6e636fa4a6296eca431cb4035e6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d9f5e6e636fa4a6296eca431cb4035e6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2、不可重复读：</span></span></h3><div id="https://www.notion.so/04ca086e4a7b4ce2a6b7ef1b9f6c03b9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在一个事务A中多次操作数据，在事务操作过程中(未最终提交)，事务B也才做了处理，并且该值发生了改变，这时候就会导致A在事务操作的时候，发现数据与第一次不一样了。 就是不可重复读。</span></span></p></div><div id="https://www.notion.so/2ac59533d28e4729a2a87769a32d6b82" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">此情况仅会发生在：读未提交、读提交的隔离级别.</strong></span></span></p></div><h3 id="https://www.notion.so/a90d4dd5ef7940a0aeda9688d3026665" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a90d4dd5ef7940a0aeda9688d3026665"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3、幻读</span></span></h3><div id="https://www.notion.so/eca890f453f84692a505a0e4d573dd73" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</span></span></p></div><div id="https://www.notion.so/d57101c0f42546568bc4eae5593487eb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">幻读是指当事务不是独立执行时发生的一种现象.</span></span></p></div><div id="https://www.notion.so/6742f767f0104f4baf472aafcef26bdb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。</span></span></p></div><div id="https://www.notion.so/20fc04009e174594a4b861b2e9955031" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。</span></span></p></div><div id="https://www.notion.so/461c583e2bcd4d518d72e4cf77af8f54" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样. 一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</span></span></p></div><div id="https://www.notion.so/71514912f12948bf91747abc74604a3a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">此情况会回发生在：读未提交、读提交、可重复读的隔离级别.</strong></span></span></p></div><h2 id="https://www.notion.so/989f48572baa4b27a87ef3557162a470" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/989f48572baa4b27a87ef3557162a470"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">索引</span></span></h2><h3 id="https://www.notion.so/e8b5fcc94f754917bb73dd3e56657087" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e8b5fcc94f754917bb73dd3e56657087"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">索引模型</span></span></h3><div id="https://www.notion.so/5890d06236b941a6ab63d26a58a3a124" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/8f8c07ecb1e4421f95b8156276c97106" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8f8c07ecb1e4421f95b8156276c97106"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">InnoDB</span></span></h3><div id="https://www.notion.so/ec4e75f8e8f3440590e2627b6e958b50" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">索引类型</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/5b81e386c9aa45b3a2b3b54694d0acb0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">*主键索引：**主键索引的叶子节点存的是整行的数据(聚簇索引)，</span></span></li><li id="https://www.notion.so/0196d165cdc248089b263044b978e551" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">*非主键索引：**非主键索引的叶子节点内容是主键的值(二级索引)</span></span></li></ul><div id="https://www.notion.so/47d3c18f83c44b5fb892aca7e8a7ddeb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主键索引和普通索引的区别：</strong></span></span></p></div><div id="https://www.notion.so/b2d9aeb720a6401fb644858740c6e42c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">1、主键索引只要搜索ID这个B+Tree即可拿到数据。
如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树</span></span></p></div><div id="https://www.notion.so/361870848ad2424cacd157245941ef16" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2、普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
如果语句是 select * from T where k=k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到到 		ID 的值为 500，再到 ID 索引树搜索一次。这个过程为回表也就是说，基于非主键索引的查询需要		多扫描一棵树</span></span></p></div><div id="https://www.notion.so/596cbf0dfe664ffca6b6552236cf3d50" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">也就是说，基于非主键索引的查询需要多扫描一棵树，因此，我们在应用中应该尽量使用主键查询</strong></span></span></p></div><div id="https://www.notion.so/b14308099bca4d46be21558d0ba1b95c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong></span></span></p></div><div id="https://www.notion.so/88425d557fa441c7817b228f9f340aaa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">最左前缀原则</strong></span></span></p></div><div id="https://www.notion.so/9f207e84ed6648e9aee8797c5ad47340" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不只是索引的全部定义，只要满足最左前缀，就可以可利用索引来加速检索、这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</strong></span></span></p></div><h2 id="https://www.notion.so/bee9e1bcd5ae4de9b64289221700230b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/bee9e1bcd5ae4de9b64289221700230b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MVCC的实现</span></span></h2><div id="https://www.notion.so/297a37902a1c480ea4148b0158e96107" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</span></span></p></div><div id="https://www.notion.so/6bc0b05200544dcd953b6bb9d22b2553" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面看一下在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">REPEATABLE READ</strong></span><span class="SemanticString">隔离级别下，MVCC具体是如何操作的。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/6ee0c95fee254c3882d8a31b20c88f51" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">SELECT</span></span><div id="https://www.notion.so/beb47b5d7e7a4bda99777be73261298e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB会根据以下两个条件检查每行记录：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/f5a35b61f5a0441a9a63c3183b1a2e13" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</span></span></li><li id="https://www.notion.so/533e62c7f78f490292480b3feb5aaf62" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</span></span></li></ol><div id="https://www.notion.so/a3f559cbcff1434383aa8dfc87bcc879" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">只有符合上述两个条件的记录，才能返回作为查询结果</span></span></p></div></li><li id="https://www.notion.so/ed84fc7d59a246678adf907fa8378e49" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">INSERT</span></span><div id="https://www.notion.so/6d234719fbb94ba8b172860509d62cd1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</span></span></p></div></li><li id="https://www.notion.so/0fb3fc032e2d48d895876d9cda69ea6b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">DELETE</span></span><div id="https://www.notion.so/6f01cd56411d4ecaacbc3e5fb88c654b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</span></span></p></div></li><li id="https://www.notion.so/5f658cc217264b719761dd73ae95c583" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">UPDATE</span></span><div id="https://www.notion.so/9d6a1ae139c043cb813bb654fbdef4fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</span></span></p></div><div id="https://www.notion.so/f97f94b38fa54cbea60938c1e250e59f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</span></span></p></div></li></ul><h2 id="https://www.notion.so/d3c1f8f23502413f87cd987a588709aa" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/d3c1f8f23502413f87cd987a588709aa"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">锁</span></span></h2><h3 id="https://www.notion.so/fb7627396516494b97c571100cc4935f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/fb7627396516494b97c571100cc4935f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">全局锁</span></span></h3><div id="https://www.notion.so/0de4f5e196fc438e8bfeafd8595e7556" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">全局锁就是对整个数据库实例加锁。
MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/82867339a810426dad1bcb7c1c4f69b8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">1、数据更新语句（数据的增删改）</span></span></li><li id="https://www.notion.so/b6fcba0f2637406a8c0938ea94a1dc34" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">2、数据定义语句（包括建表、修改表结构等）</span></span></li><li id="https://www.notion.so/6ebb64c106094139a9320c4c8e7c834b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">3、更新类事务的提交语句。</span></span></li></ul><div id="https://www.notion.so/cc6bafb831b144ae9d3acaa2d0075734" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">全局锁使用场景</strong></span></span></p></div><div id="https://www.notion.so/050ba121c43b4eae871ca02487b68a6e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">全局锁的典型使用场景是，做全库逻辑备份、也就是把整库每个表都 select 出来存成文本。</span></span></p></div><div id="https://www.notion.so/e4db9e186c904413a4423bbdebd8b14d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">缺点</strong></span></span></p></div><div id="https://www.notion.so/cac854c5714c4e3ba838fd6199b49105" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/e080e68db45649f6a1c14bdbbd98f1f5" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</span></span></li><li id="https://www.notion.so/c006b320c2564d61a4b354207911281e" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟</span></span></li></ol><div id="https://www.notion.so/7f59686434a740fda584396ffab3a001" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction的时候，导数据之前就会启动一个事务（可重复读），来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</strong></span></span></p></div><div id="https://www.notion.so/4bd167ba304c4e07983952780e34863b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一致性读是好，但前提是引擎要支持这个隔离级别</strong></span><span class="SemanticString">。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL 命令了。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/c4b6a33383f34da2a56d388488e67649" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">*所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。**这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</span></span></li></ul><div id="https://www.notion.so/b4405121db084ba7b950800b384f5b4c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">你也许会问，既然要全库只读，**为什么不使用 set global readonly=true 的方式呢？**确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8d5d69ba31cd491684c623a0ffb4adab" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</span></span></li><li id="https://www.notion.so/366a45d72e0e48a8b718631cde807494" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">而将整个 库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</strong></span></span></li></ul><h3 id="https://www.notion.so/e13aaaeda9b84451bb65212af718b263" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e13aaaeda9b84451bb65212af718b263"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">表级锁</span></span></h3><div id="https://www.notion.so/76e0a32ef11a4b36991e656372fff390" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</span></span></p></div><h3 id="https://www.notion.so/698fe05663d64a5f83596de579e14925" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/698fe05663d64a5f83596de579e14925"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">表锁</span></span></h3><div id="https://www.notion.so/b779994b6fde41028238193708e09a7d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></span></span></p></div><div id="https://www.notion.so/81d884da7d5c45efa34684aea5739a1a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</span></span></p></div><div id="https://www.notion.so/ad9669ad3f5544749ef512820fdc863e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</span></span></p></div><h3 id="https://www.notion.so/791c9f66c17d41f182b8812bd3acee5e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/791c9f66c17d41f182b8812bd3acee5e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">元数据锁</span></span></h3><div id="https://www.notion.so/075a85bba3c44b52aa533361f3e64322" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查
询线程拿到的结果跟表结构对不上，肯定是不行的。</span></span></p></div><div id="https://www.notion.so/47f01fdf52d7444798b8fdcf04e71621" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/e1a9ff3368d1443995ccee5dd7ead57e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查（这里增删改查对于表中数据，所以出现脏读、幻读、不可重复读；记住这是表级锁，为的是表结构统一）。</span></span></li><li id="https://www.notion.so/98870db818334e358a819291ff089828" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</span></span></li></ul><h3 id="https://www.notion.so/1d02564b736946fb851e77629a8aba51" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/1d02564b736946fb851e77629a8aba51"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">行锁</span></span></h3><div id="https://www.notion.so/ff43a810b71547bd933292d8ffab2070" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</span></span></p></div><div id="https://www.notion.so/171ef18406914f51aef072048e84a696" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们今天就主要来聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。</span></span></p></div><div id="https://www.notion.so/ca92befd40f84d53af5f8204af7a1b03" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</strong></span></span></p></div><div id="https://www.notion.so/c207baabec474c8dad444227ffc05a0d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">两阶段锁</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/34e0d757799f4e94b91c78d8bc982721" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></span></span></p></div><h3 id="https://www.notion.so/c3bcd9f51fe046b9a2c34da2bbe8abab" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c3bcd9f51fe046b9a2c34da2bbe8abab"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">死锁和死锁等待</span></span></h3><div id="https://www.notion.so/905837ce65874c059c3809ece92fa746" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</span></span></p></div><div id="https://www.notion.so/c774f55fa0aa41bea95529752cac8e42" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">当出现死锁以后，有两种策略</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/1170fa0eb8244a6ea40703031dacd679" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">*一种策略是，直接进入等待，直到超时。**这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。</span></span></li></ul><div id="https://www.notion.so/8496db3bb5224bb49ed7f18187e7876a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong></span><span class="SemanticString">。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</span></span></p></div><div id="https://www.notion.so/493c643449ce410f9e42081eb874780f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、InnoDB 中，innodb_lock_wait_timeout 的默认值是？</strong></span></span></p></div><div id="https://www.notion.so/846fa05dd0934dfe921a1134e4251105" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s</span></span></p></div><div id="https://www.notion.so/1e1864ca2411495982d728c9ddf42c26" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、innodb_lock_wait_timeout 设置大小的影响</strong></span></span></p></div><div id="https://www.notion.so/e4d351eae9c64e5a99747ab985a2046a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的</strong></span><span class="SemanticString">。但是，我们又不可能直接把这个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">时间设置成一个很小的值</strong></span><span class="SemanticString">，比如 1s。这样当出现死锁的时候，确实很快就可以解开，**但如果不是死锁，而是简单的锁等待呢？**所以，**超时时间设置太短的话，会出现很多误伤。 **</span></span></p></div><div id="https://www.notion.so/152f5492079b457788c9cdc84b19196a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">正常情况下我们采用第二种策略</strong></span></span></p></div><div id="https://www.notion.so/885996f0fee0479b8621f6c0ed72beae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect 的默认值本身就是 on。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">你可以想象一下这个过程</strong></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</strong></span></span></p></div><div id="https://www.notion.so/2560d237d5394f9a848af807cd121f6e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第二种策略存在的问题解决</strong></span></span></p></div><div id="https://www.notion.so/eb85b00a96414c21898d28a528791382" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复
杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就
是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU
资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/25f43b24574846ec9c006b26fb9744fc" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</strong></span></span></li><li id="https://www.notion.so/019d8e776c26447594b1013b561d9643" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">控制并发度</strong></span></span><div id="https://www.notion.so/31732edb25e04cc78e1234fafdb12762" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多</strong></span><span class="SemanticString">。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</span></span></p></div><div id="https://www.notion.so/0ab8833c0895483486bcaa73d49dd1fb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因此，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">这个并发控制要做在</strong></span></span></p></div><div id="https://www.notion.so/738c30cd7b7344c7bcb367275e29761d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">1、数据库服务端。</span></span></p></div><div id="https://www.notion.so/f2b3384c21404428a1812e068ab72315" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">2、如果你有中间件，可以考虑在中间件实现；基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了</span></span></p></div><div id="https://www.notion.so/9e7c6801887a471b9635b2a1c178ddd7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">3、如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</span></span></p></div></li></ol><div id="https://www.notion.so/f54f3cbd081e43a3a37e1bdcb40c2d0d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">悲观锁(Pessimistic Locking)，悲观锁是指在数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制实现。</strong></span></span></p></div><div id="https://www.notion.so/729fea2dbe794245ba781c136fd00f36" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。</strong></span></span></p></div><h2 id="https://www.notion.so/e0f6955fa6a842769214d9b04bb2abac" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e0f6955fa6a842769214d9b04bb2abac"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">集群</span></span></h2><h3 id="https://www.notion.so/fceb1cc0aafe4afd8b6f8021d0eb388f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/fceb1cc0aafe4afd8b6f8021d0eb388f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">主从复制</span></span></h3><div id="https://www.notion.so/0700f304546d49d088cb00e918d72551" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（1）</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Master</code></span><span class="SemanticString">服务器将数据的改变记录二进制</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Binlog</code></span><span class="SemanticString">日志，当</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Master</code></span><span class="SemanticString">上的数据发生改变时，则将其改变写入二进制日志中；</span></span></p></div><div id="https://www.notion.so/dd211bbf89b846009f69226e557d3219" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（2）</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Slave</code></span><span class="SemanticString">服务器会在一定时间间隔内对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Master</code></span><span class="SemanticString">二进制日志进行探测其是否发生改变，如果发生改变，则开始一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">I/OThread</code></span><span class="SemanticString">请求</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Master</code></span><span class="SemanticString">二进制事件</span></span></p></div><div id="https://www.notion.so/1f5b59df21f44bc4a9ff1b11ba07fad9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（3）同时主节点为每个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">I/O</code></span><span class="SemanticString">线程启动一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Dump</code></span><span class="SemanticString">线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">I/OThread</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SQLThread</code></span><span class="SemanticString">将进入睡眠状态，等待下一次被唤醒。</span></span></p></div></article>
  <footer class="Footer">
  <div>&copy; 夕的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>