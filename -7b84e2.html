<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>垃圾回收算法和垃圾收集器&nbsp;|&nbsp;夕的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="垃圾回收算法和垃圾收集器">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">垃圾回收算法和垃圾收集器</h1>
    
  </header>
  <article id="https://www.notion.so/7b84e2691aa74dcdadfea04e4c7a15d0" class="PageRoot"><h2 id="https://www.notion.so/ecf8f642947247e39d0179a673f9f379" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/ecf8f642947247e39d0179a673f9f379"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">对象是否可被回收</span></span></h2><h3 id="https://www.notion.so/5b92fa13fbcb445595516dd8ab9f74cf" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5b92fa13fbcb445595516dd8ab9f74cf"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">引用计数法</span></span></h3><div id="https://www.notion.so/a2677dd6a242435da13b5cf438819d5e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">实现原理：</strong></span><span class="SemanticString"> 为每个对象配备一个整形的计数器，例如，对象A，只要有任何对象引用了A，则A的引用计数器就加1，当引用失效时，减1；当A的引用计数器为0时，对象A就不可能再被使用，即可以进行回收。</span></span></p></div><div id="https://www.notion.so/aa4c8831bdc5488bba2160281af20ca6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">存在问题：</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c35c7cdc09ff4e4a9e40e725bc7969f1" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">无法处理循环引用的问题。所以在Java垃圾回收器中，没有使用这种方法。</span></span></li></ol><blockquote id="https://www.notion.so/0f5ebbeb05cb491580e01d74ea5619a2" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">循环引用：有对象A和B，A中含有对象B的引用，对象B中含有A的引用；此时，A和B的计数器都不为0，即无法进行回收；但是在整个系统中，没有其他对象引用了A和B，A和B是应该被回收的对象，但由于垃圾对象之间的互相引用，从而使垃圾回收器无法识别，造成内存泄漏。</span></span></blockquote><ol class="NumberedListWrapper"><li id="https://www.notion.so/2e5f49ed2d534dc6a70fc390a6170474" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">引用计数器要求每次引用产生和消除的时候，都要伴随一次加减操作，对系统性能有一定影响。</span></span></li></ol><h3 id="https://www.notion.so/bc478e6e52074676ab86af531aaeade3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/bc478e6e52074676ab86af531aaeade3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">可达性分析法</span></span></h3><div id="https://www.notion.so/58d752082120429ab18c8b5cd9417700" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">实现原理：</strong></span><span class="SemanticString"> 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链时（即不可达），则此对象不可用，可以判定为可回收对象。</span></span></p></div><div id="https://www.notion.so/165a9bcb2e5d4bf4b46e89eb2f9cec10" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可以作为 GC Roots 的对象：</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/93481460f898408dbb3e617cd1496d46" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">虚拟机栈（栈帧中的本地变量表）中引用的对象</span></span></li><li id="https://www.notion.so/de46c903a085440c9f21d5cd830a0675" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">方法区中类静态属性引用的对象</span></span></li><li id="https://www.notion.so/98cd109685e047668b98a7e6b2b7c16f" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">方法区中常量引用的对象</span></span></li><li id="https://www.notion.so/fd1c39b53b184262af851a7007e35377" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">本地方法栈中JNI（即一般说的Native方法）引用的对象</span></span></li></ol><h3 id="https://www.notion.so/cdbce1e359bb4374b1439f35516d8a78" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/cdbce1e359bb4374b1439f35516d8a78"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">判断可触及性</span></span></h3><div id="https://www.notion.so/4ab5c67e6a7e480785feadbcf7ad6996" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通过可达性分析法可以判断哪些对象不可达。一般来说，不可达对象需要被回收。但事实上，该对象有可能在某一条件下“复活自己”，如果这样，再回收就不合理了。为此需要定义对象的可触及性状态，并规定在什么状态下，可以安全回收对象。</span></span></p></div><div id="https://www.notion.so/08ca54fa5850499e9884bc4c77af9f85" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可触及性包含三种状态：</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/ce69627ad52d4fbb9739458bd41a6493" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">可触及的：从根节点出发，可以到达这个对象。</span></span></li><li id="https://www.notion.so/bff33da0027146f493416d9e39e1c445" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">可复活的：对象的所有引用都被释放，但是对象有可能在 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">finalize()</strong></span><span class="SemanticString"> 函数中复活。</span></span></li><li id="https://www.notion.so/032ec6677e8349f3b47533217857bf97" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">不可触及的：对象的finalize()函数被调用，并且没有复活，或者 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对象的 finalize() 没有重写（没必要执行）</strong></span><span class="SemanticString">， 那么就会进入不可触及状态，此时对象不可能被复活，因为 finalize() 只会被调用一次。</span></span></li></ul><div id="https://www.notion.so/06a77a0f436545e2916ec02c001c886f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对象只有在不可触及状态时，才可以被回收。</strong></span></span></p></div><div id="https://www.notion.so/0f4153bf650749be907dc214e083b0c2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">注意:</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/46144032fbfe45c684779f5a1a696c82" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">finalize()函数是一个非常糟糕的模式，不推荐使用它释放资源。</span></span></li><li id="https://www.notion.so/da058cad3aeb4a0486274521dfadd609" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">finalize() 有可能发生引用外泄，在无意中复活对象。</span></span></li><li id="https://www.notion.so/3d95b5b284fd4cd89b4ede0fed3ce8ca" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">finalize() 被系统调用，调用时间不明确。释放资源推荐在 try-catch-finally 中实现。</span></span></li></ul><h3 id="https://www.notion.so/4778b2998077497597d757d33b8b5dc7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/4778b2998077497597d757d33b8b5dc7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">引用级别</span></span></h3><div id="https://www.notion.so/e76822c98c5e49aaa7281a3721cd4509" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 提供四个级别的引用，由强到弱依次是：强引用、软引用、弱引用、虚引用。除强引用外，其他都可以在 java.lanf.ref 包中找到。</span></span></p></div><div id="https://www.notion.so/5002944ca6914232b7a3ecaee0a26bd6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不同引用级别出现的意义：</strong></span><span class="SemanticString"> 希望描述这样一类对象：当内存对象还足够时，则保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/88155712451f4fd08fdd8e1a377948dd" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">强引用：类似 Object object = new Object() 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉引用的对象。</span></span></li><li id="https://www.notion.so/617300933a064423823e5a54509efab7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">软引用：用来描述一些还有用但是非必须的对象。对于软引用关联的对象，系统将在发生内存溢出前，将这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</span></span></li><li id="https://www.notion.so/143ae32277534cfeba6de96a7be08c78" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">弱引用：用来描述非必须对象。它关联的对象只能拿生存到下一次垃圾收集发生之前，当垃圾回收器工作时，无论内存是否足够，都会回收被弱引用关联的对象。</span></span></li><li id="https://www.notion.so/f456c77051e8438ca26a358da89e25fe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">虚引用：一个对象是否有虚引用，完全不会影响其生存周期，也无法通过虚引用取得对象实例。为对象设置虚引用关联的唯一目的是能在这个对象被回收时得到系统通知。</span></span></li></ul><div id="https://www.notion.so/f2f555e7f8d04d189004c7990c158329" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">软引用，弱引用非常适合保存可有可无的缓存数据，从而加速系统运行。</strong></span></span></p></div><h2 id="https://www.notion.so/cff707e6ad784ab38e57c1f36bd38c07" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/cff707e6ad784ab38e57c1f36bd38c07"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">垃圾回收算法</span></span></h2><h3 id="https://www.notion.so/874588c9ceae42a39ebf73806e387b8a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/874588c9ceae42a39ebf73806e387b8a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">标记清除算法</span></span></h3><div id="https://www.notion.so/ec03400c16f64542b5ad755401f6e1cb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">顾名思义：此算法分为两个阶段 标记 和 清除。</span></span></p></div><div id="https://www.notion.so/eba2eef847f2449484e9a344ce5affa8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">标记：标记的过程其实就是，遍历所有的 GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</span></span></p></div><div id="https://www.notion.so/8ac3e07c9d374fa6b11a2697b618924b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</span></span></p></div><div id="https://www.notion.so/46fdbd28980a4a5fad677425ab16cb1b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不足：</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/ddc378dfc1a940658300318b3a0305be" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">效率问题：标记和清除过程的效率都不高。</span></span></li><li id="https://www.notion.so/b5a09dfb18cd4825a0e5a1b8a3073cc4" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">空间碎片问题：标记清除后会出现大量不连续的内存碎片，空间碎片太多会导致以后程序运行无法分配较大对象时，提前触发GC。</span></span></li></ol><h3 id="https://www.notion.so/03073ed49da24a07ace14d5182b7e9d3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/03073ed49da24a07ace14d5182b7e9d3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">复制算法</span></span></h3><div id="https://www.notion.so/f0994f7491584ec88593a320b703e6df" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将原有的内存空间分为两块，每次只是用其中一块，在GC时，将正在使用的内存中存活对象复制到未使用的内存块中，然后，清除正在使用内存的所有对象，交换两块内存的角色。</span></span></p></div><div id="https://www.notion.so/4228b69e0d94451b96b704fe93be5522" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">复制算法适合存活对象少、垃圾对象多的情况，所以复制算法很适合新生代（新生代中垃圾对象通常多于存活对象）。</span></span></p></div><div id="https://www.notion.so/36415029c77747ac87db671397034dd3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新生代中的 Eden 存活下来的对象，Survivor区不能完全存放，那么这些对象会通过分配担保机制进入老年代。</span></span></p></div><h3 id="https://www.notion.so/d0e2ae6740f447f5a547f7f4309e063f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d0e2ae6740f447f5a547f7f4309e063f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">标记整理算法</span></span></h3><div id="https://www.notion.so/c08a19ddbb4642f686c8c7538980620c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">标记整理算法是一种老年代的回收算法。首先需要从根节点开始，对所有可达对象做一次标记，然后将所有存活对象整理到内存的一端，之后清理边界外所有的空间。</span></span></p></div><h3 id="https://www.notion.so/63e0428e3b8045f5a39a94c3f8a62055" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/63e0428e3b8045f5a39a94c3f8a62055"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">分代收集算法</span></span></h3><div id="https://www.notion.so/755ec34ed0014bddb47d074b9331a832" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。</span></span></p></div><div id="https://www.notion.so/4fbc5be716fd4512a00bf83b9a66ef61" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于新生代，回收频率很高，但每次GC耗时很短，而老年代频率低，但会消耗更长的时间。为了支持高频率的新生代回收，虚拟机使用一种叫做卡表的数据结构。卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。</span></span></p></div><div id="https://www.notion.so/3ae4ebca263c4fa9b438d9e8dd55cdc2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这样在新生代GC时，可以不用耗大量时间扫描所有老年代对象，来确定引用关系，可以先扫描卡表，卡表位为1时，才包含新生代引用，在新生代GC时，只需扫描卡表位为1所在的老年代空间,这样可大大加快新生代回收速度。</span></span></p></div><h3 id="https://www.notion.so/3d4cd525174843838690c4e8ab5fed62" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3d4cd525174843838690c4e8ab5fed62"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">分区算法</span></span></h3><div id="https://www.notion.so/4a37b887a1b2452ba8e1dcce9a7c9488" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">分区算法将整个堆空间划分成连续的小区间。每个小区间都独立使用，独立回收。这种做法的好处是可以控制一次回收多少个小区间，从而很好的控制GC产生的停顿时间。</span></span></p></div><h2 id="https://www.notion.so/8a8edc3b9c8a422796b80f255345a8e1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8a8edc3b9c8a422796b80f255345a8e1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">垃圾回收器</span></span></h2><h3 id="https://www.notion.so/3d03ce64f6cb4dd48ce3db98b09e5a4a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3d03ce64f6cb4dd48ce3db98b09e5a4a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Serial收集器</span></span></h3><div id="https://www.notion.so/cb5fccfd81d346cd87930aaaa4e6b1c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新生代串行回收器：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/3746ab96a06d47b4beeb600b62ca9e2d" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">它只使用单线程进行垃圾回收</span></span></li><li id="https://www.notion.so/2e226d400c894409bc923bc65a902a93" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">它是独占式的垃圾回收</span></span></li></ol><div id="https://www.notion.so/0e92c95f4c654f6da14c8e1929c7c052" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于串行收集器只使用单线程回收，所以在垃圾回收时会出现“Stop The World”。这样会造成很槽糕的用户体验，在实时性要求较高的场景不适应。</span></span></p></div><div id="https://www.notion.so/8b1763f916a5458da30d570ebf61e3a3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于新生代串行收集器使用复制算法，实现相对简单，逻辑处理特别高效，而且没有线程切换开销。在单CPU处理器等硬件平台不是特别优越的场合，它的性能可以超过并行回收器和并发回收器。</span></span></p></div><h3 id="https://www.notion.so/cfa45699d63b4064a954425f9faefa34" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/cfa45699d63b4064a954425f9faefa34"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Serial Old 收集器</span></span></h3><div id="https://www.notion.so/411cb6b9d47e4fecb9f077275c84815a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">老年代串行回收器：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c1262b47183c40d5b19cd5f57f9b2a27" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">使用的是标记-整理算法</span></span></li><li id="https://www.notion.so/35dcdd8b108f4d15aa10bab7537e9ca6" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">串行的，它是独占式的</span></span></li></ol><div id="https://www.notion.so/aa027717df5e4c9197c70b0b8e8d0b28" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以作为CMS回收器的备用回收器</span></span></p></div><h3 id="https://www.notion.so/f2c06cf997fc4dd98bb04711349697f4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f2c06cf997fc4dd98bb04711349697f4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ParNew收集器</span></span></h3><div id="https://www.notion.so/59d9330a93e641b183c91cf80f6deb5e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">新生代并发回收器</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/33ba67360f8a447291d65ea5a6494be3" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">回收策略，算法，参数和新生代串行回收器一样</span></span></li><li id="https://www.notion.so/3c7b42ec6be34d0ba994386c06b2bfa3" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">回收过程进行了多线程化，但是回收过程应用程序依旧会全部暂停</span></span></li></ol><h3 id="https://www.notion.so/4e2d19b044544bd684a9cf7a5b49db33" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/4e2d19b044544bd684a9cf7a5b49db33"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Parallel Scavenge 收集器</span></span></h3><div id="https://www.notion.so/0c9882418da34c9b9e1b2e2b3b13f34f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同样也是新生代并发收集器，但是它却注重系统吞吐量。</span></span></p></div><h3 id="https://www.notion.so/42183e525a244bf2923a7ad76d9f612b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/42183e525a244bf2923a7ad76d9f612b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Parallel Old 收集器</span></span></h3><div id="https://www.notion.so/c26d112708c4467097a7d114ffdd9fb4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">老年代并发回收器，使用标记-清除算法</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/01c7f0ee24f9494884f3034963171194" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">多线程并发收集器，也是一种关注吞吐量的收集器</span></span></li></ol><h3 id="https://www.notion.so/210b050b47fb4c35b98d23d900228c69" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/210b050b47fb4c35b98d23d900228c69"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">CMS收集器</span></span></h3><div id="https://www.notion.so/0e59aba98f674080aa189d86916813b3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">老年代并发收集器，主要关注于系统停顿时间。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/63ba5d79849844df8fb6d030a54b653d" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">初始标记： STW（Stop The World）标记根对象</span></span></li><li id="https://www.notion.so/a3149ae4772b4d279505491976cf0e44" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">并发标记：标记所有对象</span></span></li><li id="https://www.notion.so/f413757cb24640bcae181954a4b8a817" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">预清理：清理前准备以及控制停顿时间</span></span></li><li id="https://www.notion.so/d24aa2e3afca448c8b7d39cd2197fdae" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">重新标记：STW，修正并发标记数据</span></span></li><li id="https://www.notion.so/cb31dca13c8d4d2ba4c3822bfa3c76b0" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">并发清理：清理垃圾</span></span></li><li id="https://www.notion.so/334ae52c0059402d9213817082db7c61" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">并发重置</span></span></li></ol><div id="https://www.notion.so/ef2aaf76f49f419f905a953ce36fa2ae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">初始标记和重新标记是独占系统资源的，而预清理、并发标记、并发清除和并发重置是可以和用户线程一起执行的。</span></span></p></div><h3 id="https://www.notion.so/7f25784879254c68ba7672a071112885" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7f25784879254c68ba7672a071112885"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">G1收集器</span></span></h3></article>
  <footer class="Footer">
  <div>&copy; 夕的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>